
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>actuator: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">sgtnserver/api/actuator/actuator.go (87.5%)</option>
				
				<option value="file1">sgtnserver/api/cchandler.go (100.0%)</option>
				
				<option value="file2">sgtnserver/api/middlewares.go (98.7%)</option>
				
				<option value="file3">sgtnserver/api/server.go (81.8%)</option>
				
				<option value="file4">sgtnserver/api/utils.go (90.0%)</option>
				
				<option value="file5">sgtnserver/api/v2/cldr/handler_cldr.go (97.5%)</option>
				
				<option value="file6">sgtnserver/api/v2/cldr/router_cldr.go (100.0%)</option>
				
				<option value="file7">sgtnserver/api/v2/combine/handler_combine.go (86.4%)</option>
				
				<option value="file8">sgtnserver/api/v2/combine/router_combine.go (100.0%)</option>
				
				<option value="file9">sgtnserver/api/v2/translation/handler_trans.go (83.9%)</option>
				
				<option value="file10">sgtnserver/api/v2/translation/middlewares.go (92.0%)</option>
				
				<option value="file11">sgtnserver/api/v2/translation/router_trans.go (100.0%)</option>
				
				<option value="file12">sgtnserver/api/v2/v2.go (100.0%)</option>
				
				<option value="file13">sgtnserver/api/validator.go (82.8%)</option>
				
				<option value="file14">sgtnserver/internal/cache/cache_manager.go (100.0%)</option>
				
				<option value="file15">sgtnserver/internal/cache/cache_ristretto.go (86.7%)</option>
				
				<option value="file16">sgtnserver/internal/common/utils.go (100.0%)</option>
				
				<option value="file17">sgtnserver/internal/config/config.go (75.0%)</option>
				
				<option value="file18">sgtnserver/internal/logger/context_logger.go (85.7%)</option>
				
				<option value="file19">sgtnserver/internal/logger/logger.go (100.0%)</option>
				
				<option value="file20">sgtnserver/internal/sgtnerror/errors.go (90.0%)</option>
				
				<option value="file21">sgtnserver/internal/sgtnerror/multierror.go (97.1%)</option>
				
				<option value="file22">sgtnserver/modules/cldr/cldrservice/cldr_service.go (95.3%)</option>
				
				<option value="file23">sgtnserver/modules/cldr/coreutil/cache/corecache.go (90.0%)</option>
				
				<option value="file24">sgtnserver/modules/cldr/coreutil/core.go (77.1%)</option>
				
				<option value="file25">sgtnserver/modules/cldr/coreutil/utils.go (95.5%)</option>
				
				<option value="file26">sgtnserver/modules/cldr/dao/dao.go (80.6%)</option>
				
				<option value="file27">sgtnserver/modules/cldr/dao/types.go (75.0%)</option>
				
				<option value="file28">sgtnserver/modules/cldr/localeutil/cache/localecache.go (80.8%)</option>
				
				<option value="file29">sgtnserver/modules/cldr/localeutil/locale.go (88.9%)</option>
				
				<option value="file30">sgtnserver/modules/cldr/localeutil/utils.go (91.7%)</option>
				
				<option value="file31">sgtnserver/modules/formatting/date.go (100.0%)</option>
				
				<option value="file32">sgtnserver/modules/translation/bundleinfo.go (92.6%)</option>
				
				<option value="file33">sgtnserver/modules/translation/bundleinfo/infoutil.go (91.7%)</option>
				
				<option value="file34">sgtnserver/modules/translation/bundleutil.go (100.0%)</option>
				
				<option value="file35">sgtnserver/modules/translation/dao/dao.go (50.0%)</option>
				
				<option value="file36">sgtnserver/modules/translation/dao/decorator/decorator.go (100.0%)</option>
				
				<option value="file37">sgtnserver/modules/translation/dao/localbundle/localbundle.go (74.3%)</option>
				
				<option value="file38">sgtnserver/modules/translation/dao/s3bundle/cryptutil.go (0.0%)</option>
				
				<option value="file39">sgtnserver/modules/translation/dao/s3bundle/s3bundle.go (63.5%)</option>
				
				<option value="file40">sgtnserver/modules/translation/dao/s3bundle/s3client.go (4.2%)</option>
				
				<option value="file41">sgtnserver/modules/translation/dao/s3bundle/s3config.go (12.0%)</option>
				
				<option value="file42">sgtnserver/modules/translation/status.go (33.3%)</option>
				
				<option value="file43">sgtnserver/modules/translation/translationcache/transcache.go (84.2%)</option>
				
				<option value="file44">sgtnserver/modules/translation/translationservice/pseudo_service.go (96.0%)</option>
				
				<option value="file45">sgtnserver/modules/translation/translationservice/trans_service.go (77.8%)</option>
				
				<option value="file46">sgtnserver/modules/translation/translationservice/utils.go (97.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
 * Copyright 2022 VMware, Inc.
 * SPDX-License-Identifier: EPL-2.0
 */

package actuator

import (
        "net/http"
        "sgtnserver/api"
        "sgtnserver/internal/logger"

        "github.com/gin-gonic/gin"
        "github.com/sinhashubham95/go-actuator"
)

type router struct{}

func (r *router) Init(g *gin.RouterGroup) <span class="cov8" title="1">{
        logger.Log.Debug("Initialize actuator router")

        g.GET("/actuator/*endpoint", actuatorHandler(g))
}</span>

func init() <span class="cov8" title="1">{
        api.Register(&amp;router{})
}</span>

func actuatorHandler(g *gin.RouterGroup) func(c *gin.Context) <span class="cov8" title="1">{
        h := actuator.GetActuatorHandler(&amp;actuator.Config{Endpoints: []int{actuator.Info}})
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                if c.Param("endpoint") == "/health" </span><span class="cov8" title="1">{
                        c.JSON(http.StatusOK, gin.H{"status": "UP"})
                }</span> else<span class="cov0" title="0"> {
                        h(c.Writer, c.Request)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file1" style="display: none">/*
 * Copyright 2022 VMware, Inc.
 * SPDX-License-Identifier: EPL-2.0
 */

package api

import (
        "net/http"

        "sgtnserver/internal/config"

        "github.com/gin-gonic/gin"
        "github.com/go-http-utils/headers"
)

// CC ...
func CC(w bool) gin.HandlerFunc <span class="cov8" title="1">{
        return newCCHandler(w).Handle
}</span>

type ccHandler struct {
        weak bool
        cc   string
}

func newCCHandler(w bool) *ccHandler <span class="cov8" title="1">{
        handler := &amp;ccHandler{
                weak: w,
                cc:   config.Settings.Server.CacheControl}
        return handler
}</span>

func (g *ccHandler) Handle(c *gin.Context) <span class="cov8" title="1">{
        if c.Request.Method == http.MethodGet </span><span class="cov8" title="1">{
                c.Writer = &amp;ccWriter{
                        request:        c.Request,
                        ResponseWriter: c.Writer,
                        weak:           g.weak,
                        cc:             g.cc}
        }</span>
}

type ccWriter struct {
        weak bool
        cc   string
        gin.ResponseWriter
        request *http.Request
}

func (w *ccWriter) Write(data []byte) (int, error) <span class="cov8" title="1">{
        if !IsHTTPSuccess(w.Status()) || !w.processCC(data) </span><span class="cov8" title="1">{
                return w.ResponseWriter.Write(data)
        }</span>
        <span class="cov8" title="1">return 0, nil</span>
}

func (w *ccWriter) processCC(bts []byte) (notModified bool) <span class="cov8" title="1">{
        etag := GenerateEtag(bts, w.weak)
        // Write ETag directly because JAVA client can't read header case-insensitively.
        w.ResponseWriter.Header()[headers.ETag] = []string{etag}
        notModified = w.request.Header.Get(headers.IfNoneMatch) == etag
        if notModified </span><span class="cov8" title="1">{
                w.ResponseWriter.WriteHeader(http.StatusNotModified)
        }</span>

        // Write Cache-Control header
        <span class="cov8" title="1">w.ResponseWriter.Header().Set(headers.CacheControl, w.cc)

        return</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">/*
 * Copyright 2022 VMware, Inc.
 * SPDX-License-Identifier: EPL-2.0
 */

package api

import (
        "math/rand"
        "net"
        "net/http"
        "net/http/httputil"
        "os"
        "regexp"
        "strings"
        "time"

        "sgtnserver/internal/common"
        "sgtnserver/internal/config"

        brotli "github.com/anargu/gin-brotli"
        "github.com/gin-contrib/cors"
        "github.com/gin-contrib/gzip"
        "github.com/gin-gonic/gin"
        "github.com/go-http-utils/headers"
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

// GinZap returns a gin.HandlerFunc (middleware) that logs requests using uber-go/zap.
func GinZap(log *zap.Logger) gin.HandlerFunc <span class="cov8" title="1">{
        rander := rand.New(rand.NewSource(time.Now().UnixNano()))

        var outsideIDTracer = getOutsideIDTracer()

        return func(c *gin.Context) </span><span class="cov8" title="1">{
                start := time.Now()

                // Add ID field to the logger
                newLog := log.With(zap.Uint32("traceId", rander.Uint32()))
                c.Set(LoggerKey, newLog)

                defer func() </span><span class="cov8" title="1">{
                        if ce := newLog.Check(zap.InfoLevel, "End a request"); ce != nil </span><span class="cov8" title="1">{
                                ce.Write(zap.Int("status", c.Writer.Status()), zap.Duration("latency", time.Since(start)))
                        }</span>
                }()

                // Print start message
                <span class="cov8" title="1">if ce := newLog.Check(zap.InfoLevel, "Start a request"); ce != nil </span><span class="cov8" title="1">{
                        fields := []zapcore.Field{
                                zap.String("method", c.Request.Method),
                                zap.String("ip", c.ClientIP()),
                                zap.String("path", c.Request.URL.Path)}
                        if query := c.Request.URL.RawQuery; len(query) &gt; 0 </span><span class="cov8" title="1">{
                                fields = append(fields, zap.String("query", query))
                        }</span>
                        <span class="cov8" title="1">ce.Write(fields...)</span>
                }

                // Print outside trace IDs
                <span class="cov8" title="1">if outsideIDTracer != nil </span><span class="cov8" title="1">{
                        if ce := newLog.Check(zap.InfoLevel, "Outside trace IDs"); ce != nil </span><span class="cov8" title="1">{
                                if traceIDs := outsideIDTracer(c); len(traceIDs) &gt; 0 </span><span class="cov8" title="1">{
                                        ce.Write(append([]zap.Field{zap.Namespace("IDs")}, traceIDs...)...)
                                }</span>
                        }
                }

                <span class="cov8" title="1">c.Next()</span>
        }
}
func getOutsideIDTracer() func(c *gin.Context) (fields []zap.Field) <span class="cov8" title="1">{
        if len(config.Settings.HeaderOfTraceID) &gt; 0 </span><span class="cov8" title="1">{
                headerNames := strings.Split(config.Settings.HeaderOfTraceID, common.ParamSep)
                return func(c *gin.Context) (fields []zap.Field) </span><span class="cov8" title="1">{
                        for _, headerName := range headerNames </span><span class="cov8" title="1">{
                                if v := c.Request.Header.Get(headerName); len(v) &gt; 0 </span><span class="cov8" title="1">{
                                        fields = append(fields, zap.String(headerName, v))
                                }</span>
                        }
                        <span class="cov8" title="1">return</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func RecoveryWithZap(log *zap.Logger) gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                defer func() </span><span class="cov8" title="1">{
                        err := recover()
                        if err == nil </span><span class="cov8" title="1">{
                                return
                        }</span>

                        <span class="cov8" title="1">if zLog, ok := c.Get(LoggerKey); ok </span><span class="cov8" title="1">{
                                log = zLog.(*zap.Logger)
                        }</span>

                        // Check for a broken connection, as it is not really a
                        // condition that warrants a panic stack trace.
                        <span class="cov8" title="1">var brokenPipe bool
                        if ne, ok := err.(*net.OpError); ok </span><span class="cov8" title="1">{
                                se, ok := ne.Err.(*os.SyscallError)
                                if ok &amp;&amp;
                                        (strings.Contains(strings.ToLower(se.Error()), "broken pipe") ||
                                                strings.Contains(strings.ToLower(se.Error()), "connection reset by peer")) </span><span class="cov8" title="1">{
                                        brokenPipe = true
                                }</span>
                        }

                        <span class="cov8" title="1">fields := []zapcore.Field{zap.Any("error", err)}
                        if brokenPipe </span><span class="cov8" title="1">{
                                httpRequest, _ := httputil.DumpRequest(c.Request, true)
                                fields = append(fields, zap.ByteString("request", httpRequest))
                        }</span> else<span class="cov8" title="1"> if gin.IsDebugging() </span><span class="cov8" title="1">{
                                httpRequest, _ := httputil.DumpRequest(c.Request, true)
                                headers := strings.Split(string(httpRequest), "\r\n")
                                for idx, header := range headers </span><span class="cov8" title="1">{
                                        current := strings.Split(header, ":")
                                        if current[0] == "Authorization" </span><span class="cov0" title="0">{
                                                headers[idx] = current[0] + ": *"
                                        }</span>
                                }
                                <span class="cov8" title="1">fields = append(fields, zap.String("request", strings.Join(headers, "\r\n")))</span>
                        }
                        <span class="cov8" title="1">log.Error("[Recovery from panic]", fields...)

                        // If the connection is dead, we can't write a status to it.
                        if brokenPipe </span><span class="cov8" title="1">{
                                c.Abort()
                        }</span> else<span class="cov8" title="1"> {
                                c.AbortWithStatus(http.StatusInternalServerError)
                        }</span>
                }()

                <span class="cov8" title="1">c.Next()</span>
        }
}

func CompressResponse() func(*gin.Context) <span class="cov8" title="1">{
        brCompressor := brotli.Brotli(brotli.DefaultCompression)
        brHandler := func(c *gin.Context) bool </span><span class="cov8" title="1">{
                if strings.Contains(c.Request.Header.Get(headers.AcceptEncoding), CompressionBrotli) </span><span class="cov8" title="1">{
                        brCompressor(c)
                        return true
                }</span>
                <span class="cov8" title="1">return false</span>
        }

        <span class="cov8" title="1">gzipCompressor := gzip.Gzip(gzip.DefaultCompression)
        gzipHandler := func(c *gin.Context) bool </span><span class="cov8" title="1">{
                if strings.Contains(c.Request.Header.Get(headers.AcceptEncoding), CompressionGzip) </span><span class="cov8" title="1">{
                        gzipCompressor(c)
                        return true
                }</span>
                <span class="cov8" title="1">return false</span>
        }

        <span class="cov8" title="1">var processors []func(c *gin.Context) bool
        for _, algorithm := range strings.Split(config.Settings.Server.CompressionAlgorithm, common.ParamAnd) </span><span class="cov8" title="1">{
                switch algorithm </span>{
                case CompressionBrotli:<span class="cov8" title="1">
                        processors = append(processors, brHandler)</span>
                case CompressionGzip:<span class="cov8" title="1">
                        processors = append(processors, gzipHandler)</span>
                }
        }

        <span class="cov8" title="1">return func(c *gin.Context) </span><span class="cov8" title="1">{
                for _, processor := range processors </span><span class="cov8" title="1">{
                        if processor(c) </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
        }
}

func HandleCrossDomain() gin.HandlerFunc <span class="cov8" title="1">{
        e := regexp.MustCompile(`\s*` + common.ParamSep + `\s*`)
        return cors.New(cors.Config{
                AllowOrigins:     e.Split(config.Settings.CrossDomain.AllowOrigin, -1),
                AllowMethods:     e.Split(config.Settings.CrossDomain.AllowMethods, -1),
                AllowHeaders:     e.Split(config.Settings.CrossDomain.AllowHeaders, -1),
                AllowCredentials: config.Settings.CrossDomain.AllowCredentials,
                MaxAge:           config.Settings.CrossDomain.MaxAge,
        })
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">/*
 * Copyright 2022-2023 VMware, Inc.
 * SPDX-License-Identifier: EPL-2.0
 */

package api

import (
        "context"
        "fmt"
        "net/http"
        "os"
        "os/signal"
        "strings"
        "sync"
        "syscall"
        "time"

        "sgtnserver/internal/common"
        "sgtnserver/internal/config"
        "sgtnserver/internal/logger"

        // "github.com/gin-contrib/pprof"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

var (
        routers []Router
        servers []*http.Server
)

func LogToZap(ginEngine *gin.Engine, zLogger *zap.Logger) <span class="cov8" title="1">{
        ginEngine.Use(GinZap(zLogger))
        ginEngine.Use(RecoveryWithZap(zLogger))
}</span>

func InitServer() *gin.Engine <span class="cov8" title="1">{
        logger.Log.Debug("Initialize server")

        ginEngine := gin.New()

        // ginEngine.RemoveExtraSlash = true

        LogToZap(ginEngine, logger.Log)

        if config.Settings.CrossDomain.Enable </span><span class="cov8" title="1">{
                ginEngine.Use(HandleCrossDomain())
        }</span>

        <span class="cov8" title="1">if len(config.Settings.Server.CompressionAlgorithm) &gt; 0 </span><span class="cov8" title="1">{
                ginEngine.Use(CompressResponse())
        }</span>

        <span class="cov8" title="1">ginEngine.Use(CC(false))

        InitValidator()

        for _, r := range routers </span><span class="cov8" title="1">{
                r.Init(&amp;ginEngine.RouterGroup)
        }</span>

        // ginEngine.GET("/loglevel", func(c *gin.Context) {
        //         LogLevel.ServeHTTP(c.Writer, c.Request)
        // })
        // ginEngine.PUT("/loglevel", func(c *gin.Context) {
        //         LogLevel.ServeHTTP(c.Writer, c.Request)
        // })

        <span class="cov8" title="1">return ginEngine</span>
}

func Register(r Router) <span class="cov8" title="1">{
        routers = append(routers, r)
}</span>

func StartServer() <span class="cov8" title="1">{
        gin.SetMode(config.Settings.Server.RunMode)

        ginEngine := InitServer()

        if config.Settings.Server.Schema == "" </span><span class="cov0" title="0">{
                logger.Log.Fatal("Schema can't be empty")
        }</span>

        <span class="cov8" title="1">const startServerInfo = "Start '%s' server listening on %s"
        const startServerError = "Fail to start %s server: %+v"

        // pprof.Register(ginEngine)

        for _, schema := range strings.Split(config.Settings.Server.Schema, common.ParamAnd) </span><span class="cov8" title="1">{
                httpServer := http.Server{
                        Handler:        ginEngine,
                        ReadTimeout:    config.Settings.Server.ReadTimeout,
                        WriteTimeout:   config.Settings.Server.WriteTimeout,
                        MaxHeaderBytes: config.Settings.Server.MaxHeaderBytes,
                }
                servers = append(servers, &amp;httpServer)

                switch schema </span>{
                case "http":<span class="cov8" title="1">
                        go func(schema string) </span><span class="cov8" title="1">{
                                httpServer.Addr = fmt.Sprintf(":%d", config.Settings.Server.HTTPPort)
                                logger.Log.Info(fmt.Sprintf(startServerInfo, schema, httpServer.Addr))
                                err := httpServer.ListenAndServe()
                                if err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                                        logger.Log.Fatal(fmt.Sprintf(startServerError, schema, err))
                                }</span>
                        }(schema)
                case "https":<span class="cov8" title="1">
                        go func(schema string) </span><span class="cov8" title="1">{
                                httpServer.Addr = fmt.Sprintf(":%d", config.Settings.Server.HTTPSPort)
                                logger.Log.Info(fmt.Sprintf(startServerInfo, schema, httpServer.Addr))
                                err := httpServer.ListenAndServeTLS(config.Settings.Server.CertFile, config.Settings.Server.KeyFile)
                                if err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                                        logger.Log.Fatal(fmt.Sprintf(startServerError, schema, err))
                                }</span>
                        }(schema)
                default:<span class="cov0" title="0">
                        logger.Log.Fatal(fmt.Sprintf("Wrong schema type: %s", schema))</span>
                }
        }
}

// WaitAndShutdownServer ...
func WaitAndShutdownServer() <span class="cov0" title="0">{
        // Wait for interrupt signal to gracefully shutdown the server with
        // a timeout of 5 seconds.
        quit := make(chan os.Signal, 1)
        // kill (no param) default send syscall.SIGTERM
        // kill -2 is syscall.SIGINT
        // kill -9 is syscall.SIGKILL but can't be catch, so don't need add it
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
        s := &lt;-quit
        logger.Log.Sugar().Infof("shutdown signal '%v' is received", s)

        ShutdownServer()
}</span>

// ShutdownServer ...
func ShutdownServer() <span class="cov8" title="1">{
        logger.Log.Info("Shutting down server...")

        // The context is used to inform the server it has 5 seconds to finish
        // the request it is currently handling
        var wg sync.WaitGroup
        for _, s := range servers </span><span class="cov8" title="1">{
                wg.Add(1)
                go func(srv *http.Server) </span><span class="cov8" title="1">{
                        defer wg.Done()
                        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
                        defer cancel()
                        if err := srv.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                                logger.Log.Error(fmt.Sprintf("Server '%s' is forced to shutdown: %+v", srv.Addr, err))
                        }</span>
                }(s)
        }

        <span class="cov8" title="1">wg.Wait()

        logger.Log.Info("Server stopped")</span>
}

type Router interface {
        Init(*gin.RouterGroup)
}
</pre>
		
		<pre class="file" id="file4" style="display: none">/*
 * Copyright 2022 VMware, Inc.
 * SPDX-License-Identifier: EPL-2.0
 */

package api

import (
        "crypto/sha1"
        "fmt"
        "net/http"

        "sgtnserver/internal/logger"
        "sgtnserver/internal/sgtnerror"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

func IsHTTPSuccess(status int) bool <span class="cov8" title="1">{
        return status &gt;= 200 &amp;&amp; status &lt; 300
}</span>

// GenerateEtag Generates an Etag for given string.
func GenerateEtag(bts []byte, weak bool) string <span class="cov8" title="1">{
        tag := fmt.Sprintf("\"%d-%s\"", len(bts), fmt.Sprintf("%x", sha1.Sum(bts)))
        if weak </span><span class="cov0" title="0">{
                tag = "W/" + tag
        }</span>

        <span class="cov8" title="1">return tag</span>
}

func GetLogger(c *gin.Context) *zap.Logger <span class="cov8" title="1">{
        if l, ok := c.Get(LoggerKey); ok </span><span class="cov8" title="1">{
                return l.(*zap.Logger)
        }</span>

        <span class="cov0" title="0">return logger.Log</span>
}

func HandleResponse(c *gin.Context, data interface{}, err error) <span class="cov8" title="1">{
        se := ToBusinessError(err)

        if IsHTTPSuccess(se.HTTPCode) </span><span class="cov8" title="1">{
                if _, ok := c.Get(VerFallbackKey); ok </span><span class="cov8" title="1">{
                        se = &amp;BusinessError{
                                Code:    sgtnerror.StatusVersionFallbackTranslation.Code(),
                                UserMsg: sgtnerror.StatusVersionFallbackTranslation.Message() + ": " + se.UserMsg}
                }</span>
        }

        <span class="cov8" title="1">if ce := c.MustGet(LoggerKey).(*zap.Logger).Check(zap.DebugLevel, ""); ce != nil </span><span class="cov8" title="1">{
                ce.Write(zap.Any("business response", se))
        }</span>

        // HTTP code is always 200
        <span class="cov8" title="1">c.JSON(http.StatusOK, Response{Error: se, Data: data})</span>
}

func AbortWithError(c *gin.Context, err error) <span class="cov8" title="1">{
        GetLogger(c).Error(err.Error())
        bError := ToBusinessError(err)
        c.AbortWithStatusJSON(http.StatusOK, Response{Error: bError})
}</span>

func ExtractParameters(c *gin.Context, uriPart, formPart interface{}) (err error) <span class="cov8" title="1">{
        if uriPart != nil </span><span class="cov8" title="1">{
                if err = c.ShouldBindUri(uriPart); err != nil </span><span class="cov8" title="1">{
                        AbortWithError(c, sgtnerror.StatusBadRequest.WithUserMessage(ExtractErrorMsg(err)))
                        return err
                }</span>
        }

        <span class="cov8" title="1">if formPart != nil </span><span class="cov8" title="1">{
                if err = c.ShouldBindQuery(formPart); err != nil </span><span class="cov8" title="1">{
                        AbortWithError(c, sgtnerror.StatusBadRequest.WithUserMessage(ExtractErrorMsg(err)))
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// ToBusinessError ...
func ToBusinessError(err error) *BusinessError <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return err_success
        }</span>

        <span class="cov8" title="1">switch e := err.(type) </span>{
        case *sgtnerror.MultiError:<span class="cov8" title="1">
                if e.ErrorOrNil() == nil </span><span class="cov8" title="1">{
                        return err_success
                }</span>
                <span class="cov8" title="1">if e.IsAllFailed() </span><span class="cov8" title="1">{
                        // If all the operations are failed, return the first error code.
                        for _, err := range e.Errors() </span><span class="cov8" title="1">{
                                if se, ok := err.(sgtnerror.Error); ok </span><span class="cov8" title="1">{
                                        return &amp;BusinessError{Code: se.Code(), HTTPCode: se.HTTPCode(), UserMsg: e.Error()}
                                }</span>
                        }
                        <span class="cov0" title="0">return &amp;BusinessError{Code: sgtnerror.UnknownError.Code(), HTTPCode: sgtnerror.UnknownError.HTTPCode(), UserMsg: e.Error()}</span>
                } else<span class="cov8" title="1"> {
                        return err_207
                }</span>
        case sgtnerror.Error:<span class="cov8" title="1">
                return &amp;BusinessError{Code: e.Code(), HTTPCode: e.HTTPCode(), UserMsg: e.Message()}</span>
        default:<span class="cov0" title="0">
                return &amp;BusinessError{Code: sgtnerror.UnknownError.Code(), HTTPCode: sgtnerror.UnknownError.HTTPCode(), UserMsg: err.Error()}</span>
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">/*
 * Copyright 2022-2023 VMware, Inc.
 * SPDX-License-Identifier: EPL-2.0
 */

package cldr

import (
        "strings"

        "sgtnserver/api"
        "sgtnserver/internal/common"
        "sgtnserver/internal/logger"
        "sgtnserver/modules/cldr"
        "sgtnserver/modules/cldr/cldrservice"
        "sgtnserver/modules/cldr/coreutil"
        "sgtnserver/modules/cldr/localeutil"

        "github.com/emirpasic/gods/maps/treemap"
        "github.com/gin-gonic/gin"
        jsoniter "github.com/json-iterator/go"
)

var json = jsoniter.ConfigDefault

// GetPatternByLocale godoc
// @Summary Get pattern data
// @Description Get pattern data in a specified locale
// @tags formatting-pattern-api
// @Produce json
// @Param locale path string true "locale String. e.g. 'en-US'"
// @Param scope query string true "pattern category string, separated by commas. e.g. 'dates,numbers,currencies,plurals,measurements,dateFields'"
// @Param scopeFilter query string false "a string for filtering the pattern data, separated by comma and underline. e.g. 'dates_eras,dates_dateTimeFormats'"
// @Success 200 {object} api.Response "OK"
// @Success 206 {object} api.Response "Successful Partially"
// @Failure 400 {string} string "Bad Request"
// @Failure 404 {string} string "Not Found"
// @Failure 500 {string} string "Internal Server Error"
// @Router /formatting/patterns/locales/{locale} [get]
func GetPatternByLocale(c *gin.Context) <span class="cov8" title="1">{
        locale := struct {
                Locale string `uri:"locale" binding:"locale"`
        }{}
        scope := PatternScope{}
        if err := api.ExtractParameters(c, &amp;locale, &amp;scope); err != nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">ctx := logger.NewContext(c, c.MustGet(api.LoggerKey))
        cldrLocale, dataMap, err := cldrservice.GetPatternByLocale(ctx, locale.Locale, scope.Scope, scope.ScopeFilter)
        var data interface{}
        if len(dataMap) &gt; 0 </span><span class="cov8" title="1">{
                parts := strings.Split(cldrLocale, cldr.LocalePartSep)
                region := coreutil.ParseRegion(parts)
                if region == "" </span><span class="cov8" title="1">{
                        region, _ = localeutil.GetLocaleDefaultRegion(ctx, cldrLocale)
                }</span>
                <span class="cov8" title="1">data = PatternData{
                        LocaleID:   cldrLocale,
                        Language:   parts[0],
                        Region:     region,
                        Categories: dataMap,
                }</span>
        }

        <span class="cov8" title="1">api.HandleResponse(c, data, err)</span>
}

// GetPatternDataByLangReg godoc
// @Summary Get pattern data
// @Description Get pattern data with language, region
// @tags formatting-pattern-api
// @Produce json
// @Param language query string true "a string which represents language, e.g. en,en-US,pt,pt-BR,zh-Hans"
// @Param region query string true "a string which represents region, e.g. US,PT,CN"
// @Param scope query string true "pattern category string, separated by commas. e.g. 'dates,numbers,currencies,plurals,measurements,dateFields'"
// @Param scopeFilter query string false "a string for filtering the pattern data, separated by comma and underline. e.g. 'dates_eras,dates_dateTimeFormats'"
// @Success 200 {object} api.Response "OK"
// @Success 206 {object} api.Response "Successful Partially"
// @Failure 400 {string} string "Bad Request"
// @Failure 404 {string} string "Not Found"
// @Failure 500 {string} string "Internal Server Error"
// @Router /formatting/patterns [get]
func GetPatternDataByLangReg(c *gin.Context) <span class="cov8" title="1">{
        params := PatternByLangRegReq{}
        if err := api.ExtractParameters(c, nil, &amp;params); err != nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">dataMap, localeToSet, mError := cldrservice.GetPatternByLangReg(logger.NewContext(c, c.MustGet(api.LoggerKey)), params.Language, params.Region, params.Scope, params.ScopeFilter)
        var data interface{}
        if len(dataMap) &gt; 0 </span><span class="cov8" title="1">{
                data = PatternData{
                        LocaleID:   localeToSet,
                        Language:   params.Language,
                        Region:     params.Region,
                        Categories: dataMap,
                }
        }</span>

        <span class="cov8" title="1">api.HandleResponse(c, data, mError)</span>
}

// GetRegionListOfLanguages godoc
// @Summary Get region names
// @Description Get region names in a specified locale
// @Tags locale-api
// @Produce json
// @Param supportedLanguageList query string true "the supported language list, separated by commas. e.g. 'en,zh,ja' "
// @Success 200 {object} api.Response "OK"
// @Success 206 {object} api.Response "Successful Partially"
// @Failure 400 {string} string "Bad Request"
// @Failure 404 {string} string "Not Found"
// @Failure 500 {string} string "Internal Server Error"
// @Router /locale/regionList [get]
func GetRegionListOfLanguages(c *gin.Context) <span class="cov8" title="1">{
        params := LocaleRegionsReq{}
        if err := api.ExtractParameters(c, nil, &amp;params); err != nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">data, multiErr := localeutil.GetTerritoriesOfMultipleLocales(logger.NewContext(c, c.MustGet(api.LoggerKey)), strings.Split(params.Locales, common.ParamSep))
        for _, d := range data </span><span class="cov8" title="1">{
                unsortedMap := map[string]interface{}{}
                d.Territories.ToVal(&amp;unsortedMap)
                sortedMap := treemap.NewWithStringComparator()
                for k, v := range unsortedMap </span><span class="cov8" title="1">{
                        sortedMap.Put(k, v)
                }</span>
                <span class="cov8" title="1">bts, _ := sortedMap.ToJSON()
                d.Territories = json.Get(bts)</span>
        }
        <span class="cov8" title="1">api.HandleResponse(c, data, multiErr)</span>
}

// GetTimeZoneNames godoc
// @Summary Get timezone names
// @Description Get time zone names in a specified locale
// @Tags formatting-api
// @Produce json
// @Param displayLanguage query string true "the display language. e.g. 'en'"
// @Param defaultTerritory query boolean false "a boolean value to get the default territory timezone name or not, default is true" default(true)
// @Success 200 {object} api.Response "OK"
// @Success 206 {object} api.Response "Successful Partially"
// @Failure 400 {string} string "Bad Request"
// @Failure 404 {string} string "Not Found"
// @Failure 500 {string} string "Internal Server Error"
// @Router /formatting/date/timezoneNameList [get]
func GetTimeZoneNames(c *gin.Context) <span class="cov8" title="1">{
        params := struct {
                DisplayLanguage  string `form:"displayLanguage" binding:"language"`
                DefaultTerritory bool   `form:"defaultTerritory"`
        }{DefaultTerritory: true}
        if err := api.ExtractParameters(c, nil, &amp;params); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">data, err := localeutil.GetTimeZoneNames(logger.NewContext(c, c.MustGet(api.LoggerKey)), params.DisplayLanguage, params.DefaultTerritory)
        api.HandleResponse(c, data, err)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">/*
 * Copyright 2022-2023 VMware, Inc.
 * SPDX-License-Identifier: EPL-2.0
 */

package cldr

import (
        v2 "sgtnserver/api/v2"
        "sgtnserver/internal/logger"

        "github.com/gin-gonic/gin"
)

type cldrRouter struct{}

func (cldr *cldrRouter) Init(e *gin.RouterGroup) <span class="cov8" title="1">{
        logger.Log.Debug("Initialize CLDR router")
        formattingGroup := e.Group("/formatting")
        </span><span class="cov8" title="1">{
                formattingGroup.GET("/patterns", GetPatternDataByLangReg)
                formattingGroup.GET("/patterns/locales/:locale", GetPatternByLocale)
                formattingGroup.GET("/date/timezoneNameList", GetTimeZoneNames)
        }</span>

        <span class="cov8" title="1">e.GET("/locale/regionList", GetRegionListOfLanguages)</span>
}

func init() <span class="cov8" title="1">{
        v2.Register(&amp;cldrRouter{})
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">/*
 * Copyright 2022-2023 VMware, Inc.
 * SPDX-License-Identifier: EPL-2.0
 */

package combine

import (
        "errors"
        "strconv"
        "strings"

        "sgtnserver/api"
        cldrApi "sgtnserver/api/v2/cldr"
        transApi "sgtnserver/api/v2/translation"
        "sgtnserver/internal/common"
        "sgtnserver/internal/logger"
        "sgtnserver/internal/sgtnerror"
        "sgtnserver/modules/cldr"
        "sgtnserver/modules/cldr/cldrservice"
        "sgtnserver/modules/cldr/coreutil"
        "sgtnserver/modules/cldr/localeutil"
        "sgtnserver/modules/translation"
        "sgtnserver/modules/translation/translationservice"

        "github.com/gin-gonic/gin"
)

var l3Service translation.Service = translationservice.GetService()

// getCombinedData godoc
// @Summary Get translation and pattern data
// @Description Get translation and pattern data by customized type
// @Tags translation-with-pattern-api
// @Produce json
// @Param combine query int true "an integer which represents combine type number 1 or 2"
// @Param productName query string true "product name"
// @Param version query string true "version"
// @Param components query string true "a string contains multiple components, separated by commas. e.g. 'cim,common,cpa,cpu'"
// @Param language query string true "a string which represents language, e.g. en,en-US,pt,pt-BR,zh-Hans"
// @Param region query string false "a string which represents region, e.g. US,PT,CN"
// @Param scope query string true "pattern category string, separated by commas. e.g. 'dates,numbers,currencies,plurals,measurements,dateFields'"
// @Param scopeFilter query string false "a string for filtering the pattern data, separated by comma and underline. e.g. 'dates_eras,dates_dateTimeFormats'"
// @Param pseudo query boolean false "a flag for returnning pseudo translation" default(false)
// @Success 200 {object} api.Response "OK"
// @Success 206 {object} api.Response "Successful Partially"
// @Failure 400 {string} string "Bad Request"
// @Failure 404 {string} string "Not Found"
// @Failure 500 {string} string "Internal Server Error"
// @Router /combination/translationsAndPattern [get]
func getCombinedData(c *gin.Context) <span class="cov8" title="1">{
        params := translationWithPatternReq{}
        if err := api.ExtractParameters(c, nil, &amp;params); err != nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">params.Version = c.GetString(api.SgtnVersionKey)
        doGetCombinedData(c, &amp;params)</span>
}

// getLanguageListOfDispLang godoc
// @Summary Get language display names
// @Description Get language display names in a specified locale
// @Tags locale-api
// @Produce json
// @Param productName query string true "product name"
// @Param version query string true "version"
// @Param displayLanguage query string false "displayLanguage"
// @Success 200 {object} api.Response "OK"
// @Success 206 {object} api.Response "Successful Partially"
// @Failure 400 {string} string "Bad Request"
// @Failure 404 {string} string "Not Found"
// @Failure 500 {string} string "Internal Server Error"
// @Router /locale/supportedLanguageList [get]
func getLanguageListOfDispLang(c *gin.Context) <span class="cov8" title="1">{
        params := languageListReq{}
        if err := api.ExtractParameters(c, nil, &amp;params); err != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">version := c.GetString(api.SgtnVersionKey)
        ctx := logger.NewContext(c, c.MustGet(api.LoggerKey))

        productLocales, err := l3Service.GetAvailableLocales(ctx, params.ProductName, version)
        if err != nil </span><span class="cov8" title="1">{
                api.AbortWithError(c, err)
                return
        }</span>

        <span class="cov8" title="1">var infos []supportedLanguageInfo
        var languagesDataOfLocale map[string]string
        var contextData map[string]interface{}

        // Get display Names when displayLanguage is provided
        if params.DisplayLanguage != "" </span><span class="cov8" title="1">{
                cldrLocale := coreutil.GetCLDRLocale(params.DisplayLanguage)
                if cldrLocale == "" </span><span class="cov8" title="1">{
                        api.AbortWithError(c, sgtnerror.StatusBadRequest.WithUserMessage(cldr.InvalidLocale, params.DisplayLanguage))
                        return
                }</span>
                <span class="cov8" title="1">languagesDataOfLocale, err = localeutil.GetLocaleLanguages(ctx, cldrLocale)
                if err != nil </span><span class="cov0" title="0">{
                        api.AbortWithError(c, err)
                        return
                }</span>
                <span class="cov8" title="1">contextData, _ = localeutil.GetContextTransforms(ctx, cldrLocale)</span>
        }

        <span class="cov8" title="1">var multiErr *sgtnerror.MultiError
        for _, pLocale := range productLocales </span><span class="cov8" title="1">{
                newLocale := pLocale
                if cldrLocale := coreutil.GetCLDRLocale(newLocale); cldrLocale != "" </span><span class="cov8" title="1">{
                        newLocale = cldrLocale
                }</span>
                <span class="cov8" title="1">if params.DisplayLanguage == "" </span><span class="cov8" title="1">{
                        // Get display name when displayLanguage isn't specified. Need to display language in itself.
                        languagesDataOfLocale, err = localeutil.GetLocaleLanguages(ctx, newLocale)
                        multiErr = sgtnerror.Append(multiErr, err)
                        // Because some locales don't have this data, so ignore the error
                        contextData, _ = localeutil.GetContextTransforms(ctx, newLocale)
                }</span>

                <span class="cov8" title="1">dispName := languagesDataOfLocale[newLocale]
                resultDataOfCurLang := supportedLanguageInfo{
                        LanguageTag:                  pLocale,
                        DisplayName:                  dispName,
                        DisplayNameSentenceBeginning: common.TitleCase(dispName),
                        DisplayNameUIListOrMenu:      dispName,
                        DisplayNameStandalone:        dispName,
                }
                if cd, ok := contextData[cldr.LanguageStr]; ok </span><span class="cov8" title="1">{
                        if cdMap, ok := cd.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                                if v, ok := cdMap[cldr.UIListOrMenu]; ok </span><span class="cov8" title="1">{
                                        resultDataOfCurLang.DisplayNameUIListOrMenu = v.(string)
                                }</span>
                                <span class="cov8" title="1">if v, ok := cdMap[cldr.StandAlone]; ok </span><span class="cov8" title="1">{
                                        resultDataOfCurLang.DisplayNameStandalone = v.(string)
                                }</span>
                        }
                }
                <span class="cov8" title="1">infos = append(infos, resultDataOfCurLang)</span>
        }

        <span class="cov8" title="1">data := map[string]interface{}{
                api.ProductNameAPIKey: params.ProductName,
                api.VersionAPIKey:     version,
                "displayLanguage":     params.DisplayLanguage,
                "languages":           infos}

        api.HandleResponse(c, data, multiErr)</span>
}

// getCombinedDataByPost godoc
// @Summary Get translation and pattern data (Deprecated because GET method is ready)
// @Description Get translation and pattern data by customized type
// @Tags translation-with-pattern-api
// @Produce json
// @Param data body translationWithPatternPostReq true "translationWithPatternPostReq"
// @Success 200 {object} api.Response "OK"
// @Success 206 {object} api.Response "Successful Partially"
// @Failure 400 {string} string "Bad Request"
// @Failure 404 {string} string "Not Found"
// @Failure 500 {string} string "Internal Server Error"
// @Router /combination/translationsAndPattern [post]
// @Deprecated
func getCombinedDataByPost(c *gin.Context) <span class="cov8" title="1">{
        params := translationWithPatternPostReq{}
        if err := c.ShouldBindJSON(&amp;params); err != nil </span><span class="cov8" title="1">{
                api.AbortWithError(c, sgtnerror.StatusBadRequest.WithUserMessage(api.ExtractErrorMsg(err)))
                return
        }</span>

        <span class="cov8" title="1">if !translationservice.IsProductAllowed(params.ProductName) </span><span class="cov0" title="0">{
                api.AbortWithError(c, sgtnerror.StatusBadRequest.WithUserMessage("Product '%s' doesn't exist", params.ProductName))
                return
        }</span>

        <span class="cov8" title="1">var pseudo bool
        var err error
        switch v := params.Pseudo.(type) </span>{
        case nil:<span class="cov8" title="1">
                pseudo = false</span>
        case string:<span class="cov0" title="0">
                if v == "" </span><span class="cov0" title="0">{
                        pseudo = false
                }</span> else<span class="cov0" title="0"> {
                        pseudo, err = strconv.ParseBool(v)
                }</span>
        case bool:<span class="cov0" title="0">
                pseudo = v</span>
        default:<span class="cov0" title="0">
                err = errors.New("wrong type")</span>
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                api.AbortWithError(c, sgtnerror.StatusBadRequest.WrapErrorWithMessage(err, "%v is an invalid boolean value", params.Pseudo))
                return
        }</span>

        <span class="cov8" title="1">params.Version = transApi.DoVersionFallback(c, params.ProductName, params.Version)

        req := translationWithPatternReq{
                Combine:    params.Combine,
                ReleaseID:  params.ReleaseID,
                Language:   params.Language,
                Region:     params.Region,
                Components: strings.Join(params.Components, common.ParamSep),
                PatternScope: cldrApi.PatternScope{
                        Scope:       params.Scope,
                        ScopeFilter: params.ScopeFilter},
                Pseudo: pseudo}
        doGetCombinedData(c, &amp;req)</span>
}

func doGetCombinedData(c *gin.Context, params *translationWithPatternReq) <span class="cov8" title="1">{
        ctx := logger.NewContext(c, c.MustGet(api.LoggerKey))

        var allErrors, translationError, patternError error
        var transData *translation.Release
        var patternDataMap map[string]interface{}
        var localeToSet, language, region = "", params.Language, params.Region
        data := new(translationWithPatternData)

        switch params.Combine </span>{
        // get pattern use parameter: language, scope, region, get the translation use parameters language, productName, version, component
        case 1:<span class="cov8" title="1">
                if len(params.Region) == 0 </span><span class="cov8" title="1">{
                        api.AbortWithError(c, sgtnerror.StatusBadRequest.WithUserMessage("Region can't be empty when combine type is %d", params.Combine))
                        return
                }</span>
                <span class="cov8" title="1">patternDataMap, localeToSet, patternError = cldrservice.GetPatternByLangReg(ctx, params.Language, params.Region, params.Scope, params.ScopeFilter)
                transData, translationError = transApi.GetService(params.Pseudo).GetMultipleBundles(ctx, params.ProductName, params.Version, params.Language, params.Components)</span>
        // get pattern use parameter: language, scope, get the translation use parameters language, productName, version, component
        case 2:<span class="cov8" title="1">
                localeToSet, patternDataMap, patternError = cldrservice.GetPatternByLocale(ctx, params.Language, params.Scope, params.ScopeFilter)
                if localeToSet != "" &amp;&amp; len(patternDataMap) &gt; 0 </span><span class="cov8" title="1">{
                        parts := strings.Split(localeToSet, cldr.LocalePartSep)
                        language = parts[0]
                        if region = coreutil.ParseRegion(parts); region == "" </span><span class="cov8" title="1">{
                                region, _ = localeutil.GetLocaleDefaultRegion(ctx, localeToSet)
                        }</span>
                }
                <span class="cov8" title="1">transData, translationError = transApi.GetService(params.Pseudo).GetMultipleBundles(ctx, params.ProductName, params.Version, params.Language, params.Components)</span>
        default:<span class="cov0" title="0">
                api.AbortWithError(c, sgtnerror.StatusBadRequest.WithUserMessage("Unsupported combination type: %d", params.Combine))
                return</span>
        }
        <span class="cov8" title="1">allErrors = sgtnerror.Append(patternError, translationError)

        for _, t := range transData.Bundles </span><span class="cov8" title="1">{
                data.Bundles = append(data.Bundles, transApi.ConvertBundleToAPI(t))
        }</span>
        <span class="cov8" title="1">if len(patternDataMap) &gt; 0 &amp;&amp; isExistPattern(patternDataMap) </span><span class="cov8" title="1">{
                data.Pattern = &amp;patternData{
                        PatternData: cldrApi.PatternData{
                                LocaleID:   localeToSet,
                                Language:   language,
                                Region:     region,
                                Categories: patternDataMap,
                        },
                        IsExistPattern: true,
                }
        }</span>

        //!+ This is for JS client which can't handle 207
        // In development env, when translation isn't ready,
        // server will return 207 because only pattern data is available.
        <span class="cov8" title="1">if bError := api.ToBusinessError(allErrors); bError.Code == 207 </span><span class="cov8" title="1">{
                api.HandleResponse(c, data, nil)
                return
        }</span>
        //!- This is for JS client which can't handle 207

        <span class="cov8" title="1">api.HandleResponse(c, data, allErrors)</span>
}

func isExistPattern(patternDataMap map[string]interface{}) bool <span class="cov8" title="1">{
        for _, v := range patternDataMap </span><span class="cov8" title="1">{
                if v != nil &amp;&amp; !common.IsZeroOfUnderlyingType(v) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">/*
 * Copyright 2022 VMware, Inc.
 * SPDX-License-Identifier: EPL-2.0
 */

package combine

import (
        v2 "sgtnserver/api/v2"
        "sgtnserver/api/v2/translation"
        "sgtnserver/internal/logger"

        "github.com/gin-gonic/gin"
)

type combineRouter struct{}

func (r *combineRouter) Init(e *gin.RouterGroup) <span class="cov8" title="1">{
        logger.Log.Debug("Initialize combination router")

        e.GET("/locale/supportedLanguageList", translation.HandleAllowList, translation.HandleVersionFallback, getLanguageListOfDispLang)

        // translations and pattern combined interface
        e.GET("/combination/translationsAndPattern", translation.HandleAllowList, translation.HandleVersionFallback, getCombinedData)

        // translations and pattern combined interface by POST (deprecated)
        e.POST("/combination/translationsAndPattern", translation.HandleAllowList, getCombinedDataByPost)

}</span>
func init() <span class="cov8" title="1">{
        v2.Register(&amp;combineRouter{})
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">/*
 * Copyright 2022-2023 VMware, Inc.
 * SPDX-License-Identifier: EPL-2.0
 */

package translation

import (
        "io/ioutil"
        "sgtnserver/api"
        "sgtnserver/internal/common"
        "sgtnserver/internal/logger"
        "sgtnserver/internal/sgtnerror"
        "sgtnserver/modules/translation"
        "sgtnserver/modules/translation/translationservice"
        "strings"

        "github.com/emirpasic/gods/sets/linkedhashset"
        "github.com/gin-gonic/gin"
        jsoniter "github.com/json-iterator/go"
)

var l3Service translation.Service = translationservice.GetService()
var pseudoService translation.Service = translationservice.GetPseudoService(l3Service)

func GetService(pseudo bool) translation.Service <span class="cov8" title="1">{
        if pseudo </span><span class="cov8" title="1">{
                return pseudoService
        }</span> else<span class="cov8" title="1"> {
                return l3Service
        }</span>
}

// GetAvailableComponents godoc
// @Summary Get component names
// @Description Get available component names in the product
// @Tags translation-product-api
// @Produce json
// @Param productName path string true "product name"
// @Param version path string true "version"
// @Success 200 {object} api.Response "OK"
// @Failure 400 {string} string "Bad Request"
// @Failure 404 {string} string "Not Found"
// @Failure 500 {string} string "Internal Server Error"
// @Router /translation/products/{productName}/versions/{version}/componentlist [get]
func GetAvailableComponents(c *gin.Context) <span class="cov8" title="1">{
        params := ReleaseID{}
        if err := api.ExtractParameters(c, &amp;params, nil); err != nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">version := c.GetString(api.SgtnVersionKey)

        components, err := l3Service.GetAvailableComponents(logger.NewContext(c, c.MustGet(api.LoggerKey)), params.ProductName, version)
        data := gin.H{
                api.ProductNameAPIKey: params.ProductName,
                api.VersionAPIKey:     version,
                api.ComponentsAPIKey:  components}
        api.HandleResponse(c, data, err)</span>
}

// GetAvailableLocales godoc
// @Summary Get locale names
// @Description Get available locale names in the product
// @Tags translation-product-api
// @Produce json
// @Param productName path string true "product name"
// @Param version path string true "version"
// @Success 200 {object} api.Response "OK"
// @Failure 400 {string} string "Bad Request"
// @Failure 404 {string} string "Not Found"
// @Failure 500 {string} string "Internal Server Error"
// @Router /translation/products/{productName}/versions/{version}/localelist [get]
func GetAvailableLocales(c *gin.Context) <span class="cov8" title="1">{
        params := ReleaseID{}
        if err := api.ExtractParameters(c, &amp;params, nil); err != nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">version := c.GetString(api.SgtnVersionKey)

        locales, err := l3Service.GetAvailableLocales(logger.NewContext(c, c.MustGet(api.LoggerKey)), params.ProductName, version)
        data := gin.H{
                api.ProductNameAPIKey: params.ProductName,
                api.VersionAPIKey:     version,
                api.LocalesAPIKey:     locales}
        api.HandleResponse(c, data, err)</span>
}

// GetMultipleBundles godoc
// @Summary Get messages of the product
// @Description Get messages of all the product or parts of the product
// @Tags translation-product-api
// @Produce json
// @Param productName path string true "product name"
// @Param version path string true "version"
// @Param locales query string false "locales"
// @Param components query string false "components"
// @Param pseudo query boolean false "a flag for returnning pseudo translation" default(false)
// @Success 200 {object} api.Response "OK"
// @Success 206 {object} api.Response "Successful Partially"
// @Failure 400 {string} string "Bad Request"
// @Failure 404 {string} string "Not Found"
// @Failure 500 {string} string "Internal Server Error"
// @Router /translation/products/{productName}/versions/{version} [get]
func GetMultipleBundles(c *gin.Context) <span class="cov8" title="1">{
        params := ProductReq{}
        if err := api.ExtractParameters(c, &amp;params, &amp;params); err != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">version := c.GetString(api.SgtnVersionKey)

        transService := GetService(params.Pseudo)
        ctx := logger.NewContext(c, c.MustGet(api.LoggerKey))
        releaseData, multiErr := transService.GetMultipleBundles(ctx, params.ProductName, version, params.Locales, params.Components)
        if multiErr != nil &amp;&amp; releaseData != nil &amp;&amp; len(releaseData.Bundles) &gt; 0 </span><span class="cov8" title="1">{
                // make up failed bundles because JAVA client needs them when successful partially
                var locales, components []string
                if params.Locales == "" </span><span class="cov0" title="0">{
                        locales, _ = transService.GetAvailableLocales(ctx, params.ProductName, version)
                }</span> else<span class="cov8" title="1"> {
                        locales = strings.Split(params.Locales, common.ParamSep)
                }</span>
                <span class="cov8" title="1">if params.Components == "" </span><span class="cov0" title="0">{
                        components, _ = transService.GetAvailableComponents(ctx, params.ProductName, version)
                }</span> else<span class="cov8" title="1"> {
                        components = strings.Split(params.Components, common.ParamSep)
                }</span>

                <span class="cov8" title="1">allBundles := make([]*translation.Bundle, 0, len(locales)*len(components))
                for _, locale := range locales </span><span class="cov8" title="1">{
                        locale = translationservice.PickupLocales(params.ProductName, version, []string{locale})[0]
                        for _, component := range components </span><span class="cov8" title="1">{
                                i := 0
                                for ; i &lt; len(releaseData.Bundles); i++ </span><span class="cov8" title="1">{
                                        bundle := releaseData.Bundles[i]
                                        if bundle.ID.Component == component &amp;&amp; bundle.ID.Locale == locale </span><span class="cov8" title="1">{
                                                allBundles = append(allBundles, bundle)
                                                break</span>
                                        }
                                }
                                <span class="cov8" title="1">if i == len(releaseData.Bundles) </span><span class="cov8" title="1">{
                                        id := translation.BundleID{Name: params.ProductName, Version: version, Component: component, Locale: locale}
                                        allBundles = append(allBundles, &amp;translation.Bundle{ID: id, Pseudo: params.Pseudo})
                                }</span>
                        }
                }
                <span class="cov8" title="1">releaseData.Bundles = allBundles</span>
        }

        <span class="cov8" title="1">api.HandleResponse(c, ConvertReleaseToAPI(releaseData), multiErr)</span>
}

// GetBundle godoc
// @Summary Get messages of a single bundle
// @Description Get messages of a single bundle
// @Tags translation-product-component-api
// @Produce json
// @Param productName path string true "product name"
// @Param version path string true "version"
// @Param locale path string true "locale name"
// @Param component path string true "component name"
// @Param pseudo query boolean false "a flag for returnning pseudo translation" default(false)
// @Param checkTranslationStatus query string false "checkTranslationStatus" default(false)
// @Success 200 {object} api.Response "OK"
// @Failure 400 {string} string "Bad Request"
// @Failure 404 {string} string "Not Found"
// @Failure 500 {string} string "Internal Server Error"
// @Router /translation/products/{productName}/versions/{version}/locales/{locale}/components/{component} [get]
func GetBundle(c *gin.Context) <span class="cov8" title="1">{
        params := GetBundleReq{}
        if err := api.ExtractParameters(c, &amp;params, &amp;params); err != nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">version := c.GetString(api.SgtnVersionKey)

        ctx := logger.NewContext(c, c.MustGet(api.LoggerKey))
        bundleID := &amp;translation.BundleID{Name: params.ProductName, Version: version, Locale: params.Locale, Component: params.Component}
        data, err := GetService(params.Pseudo).GetBundle(ctx, bundleID)
        bundleAPIData := ConvertBundleToAPI(data)

        mErr := sgtnerror.Append(err)
        if err == nil &amp;&amp; params.CheckTranslationStatus </span><span class="cov0" title="0">{
                bundleAPIData.Status, err = l3Service.GetTranslationStatus(ctx, bundleID)
                mErr = sgtnerror.Append(err)
        }</span>

        <span class="cov8" title="1">api.HandleResponse(c, bundleAPIData, mErr)</span>
}

// GetStrings godoc
// @Summary Get translations of multiple strings
// @Description Get multiple translations together by their keys
// @Tags translation-product-component-key-api
// @Produce json
// @Param productName path string true "product name"
// @Param version path string true "version"
// @Param locale path string true "locale name"
// @Param component path string true "component name"
// @Param keys query string true "keys separated by commas"
// @Param pseudo query boolean false "a flag for returning pseudo translation" default(false)
// @Success 200 {object} api.Response "OK"
// @Success 207 {object} api.Response "Successful Partially"
// @Failure 400 {string} string "Bad Request"
// @Failure 404 {string} string "Not Found"
// @Failure 500 {string} string "Internal Server Error"
// @Router /translation/products/{productName}/versions/{version}/locales/{locale}/components/{component}/keys [get]
func GetStrings(c *gin.Context) <span class="cov8" title="1">{
        uriPart := BundleID{}
        formPart := struct {
                Keys   string `form:"keys" binding:"required"`
                Pseudo bool   `form:"pseudo"`
        }{}
        if err := api.ExtractParameters(c, &amp;uriPart, &amp;formPart); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">version := c.GetString(api.SgtnVersionKey)

        bundleID := &amp;translation.BundleID{Name: uriPart.ProductName, Version: version, Locale: uriPart.Locale, Component: uriPart.Component}
        data, err := GetService(formPart.Pseudo).GetStrings(logger.NewContext(c, c.MustGet(api.LoggerKey)), bundleID, strings.Split(formPart.Keys, common.ParamSep))
        api.HandleResponse(c, ConvertBundleToAPI(data), err)</span>
}

// GetString godoc
// @Summary Get a string's translation
// @Description Get a message by its key
// @Tags translation-product-component-key-api
// @Produce json
// @Param productName path string true "product name"
// @Param version path string true "version"
// @Param locale path string true "locale name"
// @Param component path string true "component name"
// @Param key path string true "key"
// @Param pseudo query boolean false "a flag for returnning pseudo translation" default(false)
// @Param source query string false "a source string"
// @Success 200 {object} api.Response "OK"
// @Failure 400 {string} string "Bad Request"
// @Failure 404 {string} string "Not Found"
// @Failure 500 {string} string "Internal Server Error"
// @Router /translation/products/{productName}/versions/{version}/locales/{locale}/components/{component}/keys/{key} [get]
// @Deprecated
func GetString(c *gin.Context) <span class="cov8" title="1">{
        params := GetStringReq{}
        if err := api.ExtractParameters(c, &amp;params, &amp;params); err != nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">version := c.GetString(api.SgtnVersionKey)

        internalID := translation.MessageID{Name: params.ProductName, Version: version, Locale: params.Locale, Component: params.Component, Key: params.Key}
        result, err := GetService(params.Pseudo).GetStringWithSource(logger.NewContext(c, c.MustGet(api.LoggerKey)), &amp;internalID, params.Source)
        api.HandleResponse(c, result, err)</span>
}

// GetStringByPost godoc
// @Summary Post a source
// @Description Post a source
// @Tags translation-product-component-key-api
// @Produce json
// @Param productName path string true "product name"
// @Param version path string true "version"
// @Param locale path string true "locale name"
// @Param component path string true "component name"
// @Param key path string true "key"
// @Param pseudo query boolean false "a flag for returnning pseudo translation" default(false)
// @Param source body string false "a source string"
// @Param checkTranslationStatus query string false "checkTranslationStatus" default(false)
// @Success 200 {object} api.Response "OK"
// @Failure 400 {string} string "Bad Request"
// @Failure 404 {string} string "Not Found"
// @Failure 500 {string} string "Internal Server Error"
// @Router /translation/products/{productName}/versions/{version}/locales/{locale}/components/{component}/keys/{key} [post]
// @Deprecated
func GetStringByPost(c *gin.Context) <span class="cov0" title="0">{
        params := GetStringByPostReq{}
        if err := api.ExtractParameters(c, &amp;params, &amp;params); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if c.Request.Body != nil </span><span class="cov0" title="0">{
                if bts, err := ioutil.ReadAll(c.Request.Body); err != nil </span><span class="cov0" title="0">{
                        api.AbortWithError(c, sgtnerror.StatusBadRequest.WrapErrorWithMessage(err, "fail to read request body"))
                        return
                }</span> else<span class="cov0" title="0"> {
                        params.Source = string(bts)
                }</span>
        }

        <span class="cov0" title="0">internalID := translation.MessageID{Name: params.ProductName, Version: params.Version, Locale: params.Locale, Component: params.Component, Key: params.Key}
        result, err := GetService(params.Pseudo).GetStringWithSource(logger.NewContext(c, c.MustGet(api.LoggerKey)), &amp;internalID, params.Source)
        if err == nil &amp;&amp; result != nil &amp;&amp; params.CheckTranslationStatus </span><span class="cov0" title="0">{
                if result["status"].(translation.TranslationStatus).IsReady() </span><span class="cov0" title="0">{
                        err = sgtnerror.TranslationReady
                }</span> else<span class="cov0" title="0"> {
                        err = sgtnerror.TranslationNotReady
                }</span>
        }

        <span class="cov0" title="0">api.HandleResponse(c, result, err)</span>
}

// PutBundles godoc
// @Summary Update bundles
// @Description Update bundles
// @Tags translation-sync-api
// @Accept  json
// @Produce json
// @Param productName path string true "product name"
// @Param version path string true "version"
// @Param translationData body UpdateTranslationDTO true "translationData"
// @Success 200 {object} api.Response "OK"
// @Success 206 {object} api.Response "Successful Partially"
// @Failure 400 {string} string "Bad Request"
// @Failure 404 {string} string "Not Found"
// @Failure 500 {string} string "Internal Server Error"
// @Router /translation/products/{productName}/versions/{version} [put]
func PutBundles(c *gin.Context) <span class="cov8" title="1">{
        uriPart := ReleaseID{}
        if err := api.ExtractParameters(c, &amp;uriPart, nil); err != nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">params := UpdateTranslationDTO{}
        if err := c.ShouldBindJSON(&amp;params); err != nil </span><span class="cov8" title="1">{
                api.AbortWithError(c, sgtnerror.StatusBadRequest.WithUserMessage(api.ExtractErrorMsg(err)))
                return
        }</span>

        <span class="cov8" title="1">if uriPart.ProductName != params.Data.ProductName || uriPart.Version != params.Data.Version </span><span class="cov8" title="1">{
                api.AbortWithError(c, sgtnerror.StatusBadRequest.WithUserMessage("Product name/version should be consistent between URL and post data"))
                return
        }</span>

        <span class="cov8" title="1">err := l3Service.PutBundles(logger.NewContext(c, c.MustGet(api.LoggerKey)), ConvertBundleToInternal(params.Data))
        api.HandleResponse(c, nil, err)</span>
}

func ConvertBundleToInternal(apiData *UpdateBundle) []*translation.Bundle <span class="cov8" title="1">{
        productName, version := apiData.ProductName, apiData.Version
        internalData := make([]*translation.Bundle, 0, len(apiData.Translation))
        for _, ad := range apiData.Translation </span><span class="cov8" title="1">{
                id := translation.BundleID{Name: productName, Version: version, Locale: ad.Locale, Component: ad.Component}
                marshaled, _ := jsoniter.Marshal(ad.Messages)
                internalData = append(internalData, &amp;translation.Bundle{ID: id, Messages: jsoniter.Get(marshaled)})
        }</span>

        <span class="cov8" title="1">return internalData</span>
}

func ConvertReleaseToAPI(release *translation.Release) *ReleaseData <span class="cov8" title="1">{
        if release == nil || len(release.Bundles) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">pData := ReleaseData{ProductName: release.Name, Version: release.Version, Pseudo: release.Pseudo}
        localeSet, componentSet := linkedhashset.New(), linkedhashset.New()
        for _, d := range release.Bundles </span><span class="cov8" title="1">{
                pData.Bundles = append(pData.Bundles, BundleData{Component: d.ID.Component, Locale: d.ID.Locale, Messages: d.Messages})
                localeSet.Add(d.ID.Locale)
                componentSet.Add(d.ID.Component)
        }</span>
        <span class="cov8" title="1">pData.Locales = localeSet.Values()
        pData.Components = componentSet.Values()
        return &amp;pData</span>
}

func ConvertBundleToAPI(bundle *translation.Bundle) *SingleBundleData <span class="cov8" title="1">{
        if bundle == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">id := bundle.ID
        return &amp;SingleBundleData{
                ProductName: id.Name,
                Version:     id.Version,
                Locale:      id.Locale,
                Component:   id.Component,
                Messages:    bundle.Messages,
                Pseudo:      bundle.Pseudo}</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">/*
 * Copyright 2022-2023 VMware, Inc.
 * SPDX-License-Identifier: EPL-2.0
 */

package translation

import (
        "sgtnserver/api"
        "sgtnserver/internal/config"
        "sgtnserver/internal/sgtnerror"
        "sgtnserver/modules/translation/translationservice"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

// HandleVersionFallback ...
func HandleVersionFallback(c *gin.Context) <span class="cov8" title="1">{
        var ok bool
        name := c.Param(api.ProductNameAPIKey)
        if name == "" </span><span class="cov8" title="1">{
                if name, ok = c.GetQuery(api.ProductNameAPIKey); !ok </span><span class="cov8" title="1">{
                        return
                }</span>
        }
        <span class="cov8" title="1">version := c.Param(api.VersionAPIKey)
        if version == "" </span><span class="cov8" title="1">{
                if version, ok = c.GetQuery(api.VersionAPIKey); !ok </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        <span class="cov8" title="1">DoVersionFallback(c, name, version)</span>
}

func DoVersionFallback(c *gin.Context, name, version string) string <span class="cov8" title="1">{
        pickedVersion := translationservice.PickupVersion(name, version)
        c.Set(api.SgtnVersionKey, pickedVersion)
        if pickedVersion != version </span><span class="cov8" title="1">{
                c.Set(api.VerFallbackKey, true)
                api.GetLogger(c).Warn("Version fallback occurs", zap.String("from", version), zap.String("to", pickedVersion))
        }</span>

        <span class="cov8" title="1">return pickedVersion</span>
}

func HandleAllowList(c *gin.Context) <span class="cov8" title="1">{
        if !config.Settings.AllowList </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">productName := c.Param(api.ProductNameAPIKey)
        if productName == "" </span><span class="cov8" title="1">{
                var ok bool
                if productName, ok = c.GetQuery(api.ProductNameAPIKey); !ok </span><span class="cov8" title="1">{
                        return
                }</span>
        }

        <span class="cov8" title="1">if !translationservice.IsProductAllowed(productName) </span><span class="cov8" title="1">{
                api.AbortWithError(c, sgtnerror.StatusBadRequest.WithUserMessage("Product '%s' doesn't exist", productName))
        }</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">/*
 * Copyright 2022-2023 VMware, Inc.
 * SPDX-License-Identifier: EPL-2.0
 */

package translation

import (
        v2 "sgtnserver/api/v2"
        "sgtnserver/internal/logger"

        "github.com/gin-gonic/gin"
)

type translationRouter struct{}

func (r *translationRouter) Init(e *gin.RouterGroup) <span class="cov8" title="1">{
        logger.Log.Debug("Initialize translation router")

        tranGroup := e.Group("/translation", HandleAllowList, HandleVersionFallback)
        </span><span class="cov8" title="1">{
                productPart := "/products/:productName/versions/:version"

                // Product APIs
                tranGroup.GET(productPart, GetMultipleBundles)

                tranGroup.GET(productPart+"/localelist", GetAvailableLocales)
                tranGroup.GET(productPart+"/componentlist", GetAvailableComponents)

                // Component API
                tranGroup.GET(productPart+"/locales/:locale/components/:component", GetBundle)

                // Key API
                tranGroup.GET(productPart+"/locales/:locale/components/:component/keys/:key", GetString)

                // Keys API
                tranGroup.GET(productPart+"/locales/:locale/components/:component/keys", GetStrings)
        }</span>

        <span class="cov8" title="1">e.POST("/translation/products/:productName/versions/:version/locales/:locale/components/:component/keys/:key", HandleAllowList, GetStringByPost)

        e.PUT("/translation/products/:productName/versions/:version", HandleAllowList, PutBundles)</span>
}

func init() <span class="cov8" title="1">{
        v2.Register(&amp;translationRouter{})
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">/*
 * Copyright 2022 VMware, Inc.
 * SPDX-License-Identifier: EPL-2.0
 */

package v2

import (
        "sgtnserver/api"
        "sgtnserver/internal/logger"

        "github.com/gin-gonic/gin"
)

var routers []api.Router

func init() <span class="cov8" title="1">{
        api.Register(&amp;router{})
}</span>

type router struct{}

func (v2r *router) Init(g *gin.RouterGroup) <span class="cov8" title="1">{
        logger.Log.Debug("Initialize V2 router")

        v2Group := g.Group(APIRoot)

        for _, r := range routers </span><span class="cov8" title="1">{
                r.Init(v2Group)
        }</span>
}

func Register(r api.Router) <span class="cov8" title="1">{
        routers = append(routers, r)
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">/*
 * Copyright 2022 VMware, Inc.
 * SPDX-License-Identifier: EPL-2.0
 */

package api

import (
        "fmt"
        "regexp"
        "strings"

        "sgtnserver/internal/logger"

        "github.com/gin-gonic/gin/binding"
        "github.com/go-playground/locales/en"
        ut "github.com/go-playground/universal-translator"
        "github.com/go-playground/validator/v10"
        defaultEnMessages "github.com/go-playground/validator/v10/translations/en"
)

// Regular expression string
const (
        letterAndNumberAndValidCharString      = `[A-Za-z0-9_\-\.]+`
        letterAndNumberAndValidCharStringError = "Incorrect %s(only allows letter, number, dot, underline, dash)"
)

// Regular expression
var (
        letterAndNumberAndValidCharRegx = regexp.MustCompile(`^` + letterAndNumberAndValidCharString + `$`)
        versionRegex                    = regexp.MustCompile(`^\d+(\.\d+)*$`)
        componentsRegex                 = regexp.MustCompile(`^` + letterAndNumberAndValidCharString + `(,\s*` + letterAndNumberAndValidCharString + `)*$`)
        localesRegex                    = componentsRegex
        patternScopeRegex               = regexp.MustCompile(`^(\s*[a-zA-Z]+\s*)(,\s*[a-zA-Z]+\s*)*$`)
)

var validatorInfoArray = [][]interface{}{
        {VersionAPIKey, versionRegex, "Incorrect " + VersionAPIKey + "(only allows number, dot. such as 1.0.0)"},
        {ComponentAPIKey, letterAndNumberAndValidCharRegx, fmt.Sprintf(letterAndNumberAndValidCharStringError, ComponentAPIKey)},
        {LocaleAPIKey, letterAndNumberAndValidCharRegx, fmt.Sprintf(letterAndNumberAndValidCharStringError, LocaleAPIKey)},
        {LanguageAPIKey, letterAndNumberAndValidCharRegx, fmt.Sprintf(letterAndNumberAndValidCharStringError, LanguageAPIKey)},
        {RegionAPIKey, letterAndNumberAndValidCharRegx, fmt.Sprintf(letterAndNumberAndValidCharStringError, RegionAPIKey)},
        {ScopeAPIKey, patternScopeRegex, "Incorrect " + ScopeAPIKey},
        {"scopeFilter", regexp.MustCompile(`^\^?[-_a-zA-Z\d,]+$`), "Incorrect scope filter"},
        {ComponentsAPIKey, componentsRegex, fmt.Sprintf(letterAndNumberAndValidCharStringError, ComponentsAPIKey)},
        {LocalesAPIKey, localesRegex, fmt.Sprintf(letterAndNumberAndValidCharStringError, LocalesAPIKey)},
        {KeyAPIKey, letterAndNumberAndValidCharRegx, fmt.Sprintf(letterAndNumberAndValidCharStringError, KeyAPIKey)},
}

var enTranslator ut.Translator

func InitValidator() <span class="cov8" title="1">{
        logger.Log.Debug("Initialize parameter validator")

        validate, ok := binding.Validator.Engine().(*validator.Validate)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">enLocale := en.New()
        uTranslator := ut.New(enLocale)
        enTranslator, _ = uTranslator.GetTranslator(enLocale.Locale())
        err := defaultEnMessages.RegisterDefaultTranslations(validate, enTranslator)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Fatal(err.Error())
        }</span>

        <span class="cov8" title="1">for _, info := range validatorInfoArray </span><span class="cov8" title="1">{
                name, r := info[0].(string), info[1].(*regexp.Regexp)
                err := validate.RegisterValidation(name,
                        func(fl validator.FieldLevel) bool </span><span class="cov8" title="1">{
                                return r.MatchString(fl.Field().String())
                        }</span>)
                <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                        err = validate.RegisterTranslation(name, enTranslator,
                                func(ut ut.Translator) error </span><span class="cov8" title="1">{
                                        return ut.Add(name, info[2].(string), true)
                                }</span>,
                                func(ut ut.Translator, fe validator.FieldError) string <span class="cov8" title="1">{
                                        t, err := ut.T(fe.Tag())
                                        if err != nil </span><span class="cov0" title="0">{
                                                logger.Log.Warn(err.Error())
                                        }</span>
                                        <span class="cov8" title="1">return t</span>
                                })
                }
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Fatal(err.Error())
                }</span>
        }
}

func ExtractErrorMsg(err error) string <span class="cov8" title="1">{
        if vErrors, ok := err.(validator.ValidationErrors); ok </span><span class="cov8" title="1">{
                msgs := make([]string, len(vErrors))
                for i, e := range vErrors </span><span class="cov8" title="1">{
                        msgs[i] = e.Translate(enTranslator)
                }</span>
                <span class="cov8" title="1">return strings.Join(msgs, "; ")</span>
        }
        <span class="cov0" title="0">return err.Error()</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">/*
 * Copyright 2022 VMware, Inc.
 * SPDX-License-Identifier: EPL-2.0
 */

package cache

import (
        "sgtnserver/internal/logger"

        "go.uber.org/zap"
)

var caches = make(map[string]Cache)

// NewCache ...
func NewCache(name string, config map[string]interface{}) Cache <span class="cov8" title="1">{
        logger.Log.Debug("Create a new cache", zap.String("name", name), zap.Any("config", config))
        c, ok := caches[name]
        if !ok </span><span class="cov8" title="1">{
                c = NewRistrettoCache(config)
                caches[name] = c
        }</span>
        <span class="cov8" title="1">return c</span>
}

func GetCache(name string) (Cache, bool) <span class="cov8" title="1">{
        c, ok := caches[name]
        return c, ok
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">/*
 * Copyright 2022 VMware, Inc.
 * SPDX-License-Identifier: EPL-2.0
 */

package cache

import (
        "fmt"
        "time"

        "sgtnserver/internal/logger"

        "github.com/dgraph-io/ristretto"
        "go.uber.org/zap"
)

func NewRistrettoCache(config map[string]interface{}) *RistrettoCache <span class="cov8" title="1">{
        maxEntities := config["MaxEntities"].(int64)
        cache, err := ristretto.NewCache(&amp;ristretto.Config{
                NumCounters:        maxEntities * 10,
                MaxCost:            maxEntities,
                BufferItems:        64,
                IgnoreInternalCost: true,
        })
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Fatal("Fail to create cache", zap.Error(err))
        }</span>

        <span class="cov8" title="1">t, _ := config["Expiration"].(time.Duration)
        return &amp;RistrettoCache{expirationTime: t, Cache: cache}</span>
}

type RistrettoCache struct {
        expirationTime time.Duration
        *ristretto.Cache
}

func (c *RistrettoCache) Clear() error <span class="cov8" title="1">{
        c.Cache.Clear()
        return nil
}</span>

// func (c *RistrettoCache) Delete(key interface{}) error {
//         c.Cache.Del(key)
//         return nil
// }

func (c *RistrettoCache) Get(key interface{}) (interface{}, error) <span class="cov8" title="1">{
        v, found := c.Cache.Get(key)
        if found </span><span class="cov8" title="1">{
                return v, nil
        }</span> else<span class="cov8" title="1"> {
                return nil, fmt.Errorf("Not found key: '%s'", key)
        }</span>
}

func (c *RistrettoCache) Set(key, value interface{}) error <span class="cov8" title="1">{
        if c.Cache.SetWithTTL(key, value, 1, c.expirationTime) </span><span class="cov8" title="1">{
                return nil
        }</span> else<span class="cov0" title="0"> {
                return fmt.Errorf("Fail to store data to cache. key: '%s'", key)
        }</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">/*
 * Copyright 2022-2023 VMware, Inc.
 * SPDX-License-Identifier: EPL-2.0
 */

package common

import (
        "context"
        "errors"
        "reflect"
        "strings"
        "time"

        "sgtnserver/internal/logger"

        "go.uber.org/zap"
)

// Contains ...
// return &lt; 0 not found
//        &gt;=0 the index
func Contains(s []string, e string) int <span class="cov8" title="1">{
        for i, a := range s </span><span class="cov8" title="1">{
                if a == e </span><span class="cov8" title="1">{
                        return i
                }</span>
        }
        <span class="cov8" title="1">return -1</span>
}

// ContainsIgnoreCase
// return &lt; 0 not found
//        &gt;=0 the index
func ContainsIgnoreCase(s []string, e string) int <span class="cov8" title="1">{
        for i, a := range s </span><span class="cov8" title="1">{
                if strings.EqualFold(a, e) </span><span class="cov8" title="1">{
                        return i
                }</span>
        }
        <span class="cov8" title="1">return -1</span>
}

func TitleCase(s string) string <span class="cov8" title="1">{
        if s == "" </span><span class="cov8" title="1">{
                return s
        }</span>

        <span class="cov8" title="1">if s[0] &gt;= 'a' &amp;&amp; s[0] &lt;= 'z' </span><span class="cov8" title="1">{
                bts := []byte(s)
                bts[0] -= 32
                return string(bts)
        }</span>

        <span class="cov8" title="1">return s</span>
}

// DoAndCheck ...
func DoAndCheck(ctx context.Context, done chan struct{}, doer func() error, checker func(), duration time.Duration) (err error) <span class="cov8" title="1">{
        defer close(done) // Close the channel

        err = doer()
        if err != nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">timeout := time.After(duration)
        ready := make(chan struct{})

        go func() </span><span class="cov8" title="1">{
                checker()
                ready &lt;- struct{}{}
        }</span>()

        <span class="cov8" title="1">select </span>{
        case &lt;-ready:<span class="cov8" title="1"></span>
        case &lt;-timeout:<span class="cov8" title="1">
                err = errors.New("time out to wait for cache ready")
                logger.FromContext(ctx).Error(err.Error(), zap.Duration("waitTime", duration))</span>
        }

        <span class="cov8" title="1">return</span>
}

func IsZeroOfUnderlyingType(x interface{}) bool <span class="cov8" title="1">{
        return reflect.DeepEqual(x, reflect.Zero(reflect.TypeOf(x)).Interface())
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">/*
 * Copyright 2022-2023 VMware, Inc.
 * SPDX-License-Identifier: EPL-2.0
 */

package config

import (
        "flag"
        "io/ioutil"
        "log"
        "os"
        "time"

        "github.com/jaffee/commandeer"
        "github.com/spf13/pflag"
        "go.uber.org/zap/zapcore"
        "gopkg.in/yaml.v3"
)

func InitConfig(filePath string) <span class="cov8" title="1">{
        log.Printf("Initialize configuration with '%s'\n", filePath)

        contents, err := ioutil.ReadFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Fail to read '%s': %+v", filePath, err)
        }</span>

        <span class="cov8" title="1">err = yaml.Unmarshal(contents, &amp;Settings)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Fail to parse '%s': %+v", filePath, err)
        }</span>

        <span class="cov8" title="1">Settings.Cache.Enable = true

        err = pflag.CommandLine.Parse(os.Args[1:])
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Fail to parse arguments from CLI: %+v", err)
        }</span>
}

func init() <span class="cov8" title="1">{
        var cfPath = flag.String("config", "config/config.yaml", "the config file")

        pflag.CommandLine.AddGoFlagSet(flag.CommandLine)

        err := commandeer.Flags(pflag.CommandLine, &amp;Settings)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("calling Flags: %v", err)
        }</span>

        <span class="cov8" title="1">err = pflag.CommandLine.Parse(os.Args[1:])
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Fail to parse arguments from CLI: %+v", err)
        }</span>

        <span class="cov8" title="1">InitConfig(*cfPath)</span>
}

type Config struct {
        SwaggerUI bool `yaml:"SwaggerUI"`

        BundleLocation string `yaml:"BundleLocation"`

        LocalBundle struct {
                BasePath string `yaml:"BasePath"`
        } `yaml:"LocalBundle"`

        S3Bundle struct {
                PublicKeyFile   string `yaml:"PublicKeyFile"`
                AccessKey       string `yaml:"AccessKey"`
                SecretKey       string `yaml:"SecretKey"`
                RoleArn         string `yaml:"RoleArn"`
                SessionDuration int32  `yaml:"SessionDuration"`
                Region          string `yaml:"Region"`
                BucketName      string `yaml:"BucketName"`
                BundleRoot      string `yaml:"BundleRoot"`
        } `yaml:"S3Bundle"`

        RefreshBundleInterval time.Duration `yaml:"RefreshBundleInterval"`
        HeaderOfTraceID       string        `yaml:"HeaderOfTraceID"`

        Server struct {
                RunMode              string        `yaml:"RunMode"`
                Schema               string        `yaml:"Schema"`
                HTTPPort             int           `yaml:"HTTPPort"`
                HTTPSPort            int           `yaml:"HTTPSPort"`
                ReadTimeout          time.Duration `yaml:"ReadTimeout"`
                WriteTimeout         time.Duration `yaml:"WriteTimeout"`
                CertFile             string        `yaml:"CertFile"`
                KeyFile              string        `yaml:"KeyFile"`
                MaxHeaderBytes       int           `yaml:"MaxHeaderBytes"`
                CacheControl         string        `yaml:"CacheControl"`
                CompressionAlgorithm string        `yaml:"CompressionAlgorithm"`
        } `yaml:"Server"`

        LOG struct {
                // Filename is the file to write logs to.  Backup log files will be retained
                // in the same directory.  It uses &lt;processname&gt;-lumberjack.log in
                // os.TempDir() if empty.
                Filename string `json:"Filename" yaml:"Filename"`

                // MaxSize is the maximum size in megabytes of the log file before it gets
                // rotated. It defaults to 100 megabytes.
                MaxSize int `json:"MaxSize" yaml:"MaxSize"`

                // MaxAge is the maximum number of days to retain old log files based on the
                // timestamp encoded in their filename.  Note that a day is defined as 24
                // hours and may not exactly correspond to calendar days due to daylight
                // savings, leap seconds, etc. The default is not to remove old log files
                // based on age.
                MaxAge int `json:"MaxAge" yaml:"MaxAge"`

                // MaxBackups is the maximum number of old log files to retain.  The default
                // is to retain all old log files (though MaxAge may still cause them to get
                // deleted.)
                MaxBackups int `json:"MaxBackups" yaml:"MaxBackups"`

                Level zapcore.Level `json:"Level" yaml:"Level"`

                ConsoleLevel zapcore.Level `json:"ConsoleLevel" yaml:"ConsoleLevel"`
        } `yaml:"LOG"`

        Cache struct {
                Enable      bool          //`json:"Enable" yaml:"Enable"`
                MaxEntities int64         `json:"MaxEntities" yaml:"MaxEntities"`
                Expiration  time.Duration `json:"Expiration" yaml:"Expiration"`
        } `json:"Cache" yaml:"Cache"`

        CrossDomain struct {
                Enable           bool          `json:"Enable" yaml:"Enable"`
                AllowCredentials bool          `json:"AllowCredentials" yaml:"AllowCredentials"`
                AllowOrigin      string        `json:"AllowOrigin" yaml:"AllowOrigin"`
                AllowMethods     string        `json:"AllowMethods" yaml:"AllowMethods"`
                AllowHeaders     string        `json:"AllowHeaders" yaml:"AllowHeaders"`
                MaxAge           time.Duration `json:"MaxAge" yaml:"MaxAge"`
        } `json:"CrossDomain" yaml:"CrossDomain"`

        AllowList       bool   `yaml:"AllowList"`
        AllowedProducts string `json:"AllowedProducts" yaml:"AllowedProducts"`
}

var Settings Config
</pre>
		
		<pre class="file" id="file18" style="display: none">/*
 * Copyright 2022 VMware, Inc.
 * SPDX-License-Identifier: EPL-2.0
 */

package logger

import (
        "context"

        "go.uber.org/zap"
)

type key int

const loggerKey key = 0

func NewContext(ctx context.Context, d interface{}) context.Context <span class="cov8" title="1">{
        if ctx == nil </span><span class="cov0" title="0">{
                ctx = context.Background()
        }</span>
        <span class="cov8" title="1">return context.WithValue(ctx, loggerKey, d)</span>
}

func FromContext(ctx context.Context) *zap.Logger <span class="cov8" title="1">{
        if ctx != nil </span><span class="cov8" title="1">{
                if logger, ok := ctx.Value(loggerKey).(*zap.Logger); ok </span><span class="cov8" title="1">{
                        return logger
                }</span>
        }

        <span class="cov8" title="1">return Log</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">/*
 * Copyright 2022 VMware, Inc.
 * SPDX-License-Identifier: EPL-2.0
 */

package logger

import (
        "os"

        "sgtnserver/internal/config"

        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
        "gopkg.in/natefinch/lumberjack.v2"
)

var (
        // Log ...
        Log *zap.Logger

        // SLog Zap Sugar Logger
        SLog *zap.SugaredLogger

        // LogLevel ...
        // LogLevel zap.AtomicLevel
)

// InitLogger .
func InitLogger() <span class="cov8" title="1">{
        var cores []zapcore.Core

        logLevel := config.Settings.LOG.ConsoleLevel

        // First, define our level-handling logic.
        highPriority := zap.LevelEnablerFunc(func(lvl zapcore.Level) bool </span><span class="cov8" title="1">{
                return lvl &gt;= zapcore.ErrorLevel &amp;&amp; lvl &gt;= logLevel
        }</span>)
        <span class="cov8" title="1">lowPriority := zap.LevelEnablerFunc(func(lvl zapcore.Level) bool </span><span class="cov8" title="1">{
                return lvl &lt; zapcore.ErrorLevel &amp;&amp; lvl &gt;= logLevel
        }</span>)

        // High-priority output should also go to standard error, and low-priority
        // output should also go to standard out.
        <span class="cov8" title="1">consoleDebugging := zapcore.Lock(os.Stdout)
        consoleErrors := zapcore.Lock(os.Stderr)

        // file log
        if config.Settings.LOG.Filename != "" </span><span class="cov8" title="1">{
                w := zapcore.AddSync(&amp;lumberjack.Logger{
                        Filename:   config.Settings.LOG.Filename,
                        MaxSize:    config.Settings.LOG.MaxSize,
                        MaxBackups: config.Settings.LOG.MaxBackups,
                        MaxAge:     config.Settings.LOG.MaxAge,
                })
                lumberjackCore := zapcore.NewCore(
                        zapcore.NewJSONEncoder(zap.NewProductionEncoderConfig()),
                        w,
                        config.Settings.LOG.Level,
                )
                cores = append(cores, lumberjackCore)
        }</span>

        // Console Log
        <span class="cov8" title="1">consoleEncoder := zapcore.NewConsoleEncoder(zap.NewDevelopmentEncoderConfig())

        cores = append(cores,
                zapcore.NewCore(consoleEncoder, consoleErrors, highPriority),
                zapcore.NewCore(consoleEncoder, consoleDebugging, lowPriority))
        core := zapcore.NewTee(cores...)

        Log = zap.New(core, zap.AddStacktrace(highPriority))

        SLog = Log.Sugar()
        Log.Debug("Created logger")</span>
}

func init() <span class="cov8" title="1">{
        InitLogger()
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">/*
 * Copyright 2022 VMware, Inc.
 * SPDX-License-Identifier: EPL-2.0
 */

package sgtnerror

import (
        "fmt"
        "net/http"
)

var (
        StatusSuccess        = Error{code: http.StatusOK, httpCode: http.StatusOK, message: "OK"}
        TranslationNotReady  = Error{code: 205, httpCode: http.StatusOK, message: "translations are not ready"}
        TranslationReady     = Error{code: 206, httpCode: http.StatusOK, message: "translations are ready"}
        StatusPartialSuccess = Error{code: 207, httpCode: http.StatusOK, message: "Successful Partially"}

        StatusBadRequest    = Error{code: http.StatusBadRequest, httpCode: http.StatusBadRequest, message: "Bad Request"}
        StatusNotFound      = Error{code: http.StatusNotFound, httpCode: http.StatusBadRequest}
        StatusInvalidToken  = Error{code: 498, httpCode: 498, message: "Invalid Token"}
        StatusTokenRequired = Error{code: 499, httpCode: 499, message: "Token Required"}

        StatusVersionFallbackTranslation = Error{code: 604, message: "Version has been fallen back"}

        StatusInternalServerError = Error{code: http.StatusInternalServerError, httpCode: http.StatusInternalServerError, message: "Internal Server Error"}
        UnknownError              = Error{code: 520, httpCode: 520, message: "Unknown Error"}
)

type Error struct {
        cause          error
        code, httpCode int
        message        string
}

func (e Error) Code() int <span class="cov8" title="1">{
        return e.code
}</span>

func (e Error) HTTPCode() int <span class="cov8" title="1">{
        return e.httpCode
}</span>

func (e Error) Message() string <span class="cov8" title="1">{
        return e.message
}</span>

func (e Error) WithUserMessage(msg string, args ...interface{}) error <span class="cov8" title="1">{
        message := fmt.Sprintf(msg, args...)
        return Error{
                cause:    nil,
                code:     e.code,
                httpCode: e.httpCode,
                message:  message}
}</span>

func (e Error) WrapErrorWithMessage(err error, userMsg string, args ...interface{}) error <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return Error{
                cause:    err,
                code:     e.code,
                httpCode: e.httpCode,
                message:  fmt.Sprintf(userMsg, args...)}</span>
}

func (e Error) Error() string <span class="cov8" title="1">{
        var msg string
        if len(e.message) &gt; 0 </span><span class="cov8" title="1">{
                msg += e.message
        }</span>

        <span class="cov8" title="1">if e.cause != nil </span><span class="cov8" title="1">{
                msg += ": " + e.cause.Error()
        }</span>

        <span class="cov8" title="1">return msg</span>
}

type (
        Coded interface {
                Code() int
        }

        Messager interface {
                Message() string
        }
)

func GetCode(e error) int <span class="cov8" title="1">{
        if c, ok := e.(Coded); ok </span><span class="cov8" title="1">{
                return c.Code()
        }</span>
        <span class="cov0" title="0">return UnknownError.code</span>
}

func GetUserMessage(err error) string <span class="cov8" title="1">{
        if e, ok := err.(Messager); ok </span><span class="cov8" title="1">{
                return e.Message()
        }</span>
        <span class="cov0" title="0">return err.Error()</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">/*
 * Copyright 2022 VMware, Inc.
 * SPDX-License-Identifier: EPL-2.0
 */

package sgtnerror

import (
        "fmt"
        "strings"

        "github.com/hashicorp/go-multierror"
)

type MultiError struct {
        multiErrors *multierror.Error
        nilErrorNum int
}

func Append(err error, errs ...error) *MultiError <span class="cov8" title="1">{
        switch err := err.(type) </span>{
        case *MultiError:<span class="cov8" title="1">
                // Typed nils can reach here, so initialize if we are nil
                if err == nil </span><span class="cov8" title="1">{
                        err = &amp;MultiError{multiErrors: &amp;multierror.Error{ErrorFormat: FormatFunc}}
                }</span>

                // Go through each error and flatten
                <span class="cov8" title="1">for _, e := range errs </span><span class="cov8" title="1">{
                        switch e := e.(type) </span>{
                        case *MultiError:<span class="cov8" title="1">
                                if e != nil </span><span class="cov8" title="1">{
                                        err.multiErrors = multierror.Append(err.multiErrors, e.multiErrors)
                                }</span> else<span class="cov8" title="1"> {
                                        err.nilErrorNum++
                                }</span>
                        default:<span class="cov8" title="1">
                                if e != nil </span><span class="cov8" title="1">{
                                        err.multiErrors = multierror.Append(err.multiErrors, e)
                                }</span> else<span class="cov8" title="1"> {
                                        err.nilErrorNum++
                                }</span>
                        }
                }

                <span class="cov8" title="1">return err</span>
        default:<span class="cov8" title="1">
                newErrs := make([]error, 0, len(errs)+1)
                newErrs = append(newErrs, err)
                newErrs = append(newErrs, errs...)

                return Append(&amp;MultiError{multiErrors: &amp;multierror.Error{ErrorFormat: FormatFunc}}, newErrs...)</span>
        }
}

func (e *MultiError) Error() string <span class="cov8" title="1">{
        if e.ErrorOrNil() == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">return e.multiErrors.Error()</span>
}

func (e *MultiError) Errors() []error <span class="cov8" title="1">{
        if e.ErrorOrNil() == nil </span><span class="cov8" title="1">{
                return []error{}
        }</span>

        <span class="cov8" title="1">return e.multiErrors.Errors</span>
}

func (e *MultiError) ErrorOrNil() error <span class="cov8" title="1">{
        if e == nil || e.multiErrors.ErrorOrNil() == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return e</span>
}

func (e *MultiError) IsAllFailed() bool <span class="cov8" title="1">{
        if e.ErrorOrNil() != nil </span><span class="cov8" title="1">{
                return e.nilErrorNum == 0
        }</span>

        <span class="cov8" title="1">return false</span>
}

func FormatFunc(es []error) string <span class="cov8" title="1">{
        if len(es) == 1 </span><span class="cov8" title="1">{
                return GetUserMessage(es[0])
        }</span>

        <span class="cov8" title="1">points := make([]string, len(es))
        for i, err := range es </span><span class="cov8" title="1">{
                points[i] = GetUserMessage(err)
        }</span>

        <span class="cov8" title="1">return fmt.Sprintf(
                "%d errors occurred. %s",
                len(es), strings.Join(points, "; "))</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">/*
 * Copyright 2022-2023 VMware, Inc.
 * SPDX-License-Identifier: EPL-2.0
 */

package cldrservice

import (
        "context"
        "regexp"
        "strings"

        "sgtnserver/internal/common"
        "sgtnserver/internal/logger"
        "sgtnserver/internal/sgtnerror"
        "sgtnserver/modules/cldr"
        "sgtnserver/modules/cldr/coreutil"
        "sgtnserver/modules/cldr/localeutil"

        "github.com/emirpasic/gods/sets/hashset"
        jsoniter "github.com/json-iterator/go"
        "github.com/stretchr/objx"
        "go.uber.org/zap"
)

var (
        ArgSplitter = regexp.MustCompile(`\s*` + common.ParamSep + `\s*`)

        // categoriesFromLanguage these are always form language
        categoriesFromLanguage = hashset.New(cldr.PatternDateFields, cldr.PatternPlurals, cldr.PatternMeasurements, cldr.PatternCurrencies)

        // categoriesWithSupplement Need to get some extra data for these categories for front end requirements
        categoriesWithSupplement = map[string]cldr.CoreDataType{
                cldr.PatternCurrencies: cldr.CoreSplmtCurrencyData,
                cldr.PatternNumbers:    cldr.CoreSplmtNumberingSystems,
        }

        // categoriesNeedOtherCategories these categories need other categories for front end requirements
        categoriesNeedOtherCategories = map[string][]string{
                cldr.PatternCurrencies:   {cldr.PatternNumbers},
                cldr.PatternPlurals:      {cldr.PatternNumbers},
                cldr.PatternDateFields:   {cldr.PatternPlurals, cldr.PatternNumbers},
                cldr.PatternMeasurements: {cldr.PatternPlurals, cldr.PatternNumbers},
        }
)

const (
        scopeFilterSep = "_"
        objxMapPathSep = "."
)

func GetPatternByLangReg(ctx context.Context, language, region, catgs, filter string) (resultMap map[string]interface{}, cldrLocale string, err error) <span class="cov8" title="1">{
        log := logger.FromContext(ctx)
        log.Debug("Get pattern by language and region", zap.String("language", language), zap.String("region", region), zap.String("scope", catgs), zap.String("scopeFilter", filter))

        combinedLocale := coreutil.GetLocaleByLangReg(language, region)
        normalizedLanguage := coreutil.GetCLDRLocale(language)
        var returnErr *sgtnerror.MultiError

        catgFromLanguageSize := 0
        resultMap = map[string]interface{}{}
        categories := ArgSplitter.Split(catgs, -1)
        for i := 0; i &lt; len(categories); i++ </span><span class="cov8" title="1">{
                catg := categories[i]
                var catgData jsoniter.Any
                var err error
                if categoriesFromLanguage.Contains(catg) </span><span class="cov8" title="1">{ // dateFields and Plural always follow language
                        if normalizedLanguage == "" </span><span class="cov8" title="1">{
                                err = sgtnerror.StatusBadRequest.WithUserMessage(cldr.InvalidLocale, language)
                                log.Error(err.Error())
                        }</span> else<span class="cov8" title="1"> if catgData, err = localeutil.GetPatternData(ctx, normalizedLanguage, catg); err == nil </span><span class="cov8" title="1">{
                                catgFromLanguageSize++
                        }</span>
                } else<span class="cov8" title="1"> {
                        if combinedLocale == "" </span><span class="cov8" title="1">{
                                err = sgtnerror.StatusBadRequest.WithUserMessage("Can't get a locale ID with '%s' and '%s'", language, region)
                                log.Error(err.Error())
                        }</span> else<span class="cov8" title="1"> {
                                catgData, err = localeutil.GetPatternData(ctx, combinedLocale, catg)
                        }</span>
                }
                <span class="cov8" title="1">returnErr = sgtnerror.Append(returnErr, err)
                if err == nil </span><span class="cov8" title="1">{
                        resultMap[catg] = catgData
                        categories = addOtherCategories(categories, catg)
                }</span>
        }

        <span class="cov8" title="1">resultMap = processFilters(resultMap, filter)
        getSupplementalData(ctx, resultMap, returnErr)

        localeToSet := combinedLocale
        switch </span>{
        case len(resultMap) == 0:<span class="cov8" title="1">
                localeToSet = ""</span>
        case catgFromLanguageSize == len(resultMap):<span class="cov8" title="1">
                localeToSet = normalizedLanguage</span>
        case catgFromLanguageSize != 0 &amp;&amp; combinedLocale != normalizedLanguage:<span class="cov8" title="1">
                localeToSet = ""</span>
        }

        <span class="cov8" title="1">return resultMap, localeToSet, returnErr.ErrorOrNil()</span>
}

func GetPatternByLocale(ctx context.Context, locale, catgs, filter string) (newLocale string, resultMap map[string]interface{}, err error) <span class="cov8" title="1">{
        log := logger.FromContext(ctx)
        log.Debug("Get pattern by locale", zap.String("locale", locale), zap.String("scope", catgs), zap.String("scopeFilter", filter))
        newLocale = coreutil.GetCLDRLocale(locale)
        if newLocale == "" </span><span class="cov8" title="1">{
                err := sgtnerror.StatusBadRequest.WithUserMessage(cldr.InvalidLocale, locale)
                log.Error(err.Error())
                return "", nil, err
        }</span>

        <span class="cov8" title="1">var returnErr *sgtnerror.MultiError

        resultMap = map[string]interface{}{}
        categories := ArgSplitter.Split(catgs, -1)
        for i := 0; i &lt; len(categories); i++ </span><span class="cov8" title="1">{
                catg := categories[i]
                catgData, err := localeutil.GetPatternData(ctx, newLocale, catg)
                returnErr = sgtnerror.Append(returnErr, err)
                if err == nil </span><span class="cov8" title="1">{
                        resultMap[catg] = catgData
                        categories = addOtherCategories(categories, catg)
                }</span>
        }

        <span class="cov8" title="1">resultMap = processFilters(resultMap, filter)
        getSupplementalData(ctx, resultMap, returnErr)

        return newLocale, resultMap, returnErr.ErrorOrNil()</span>
}

func getSupplementalData(ctx context.Context, resultMap map[string]interface{}, returnErr *sgtnerror.MultiError) <span class="cov8" title="1">{
        suppleMap := map[string]jsoniter.Any{}
        for catg, v := range resultMap </span><span class="cov8" title="1">{
                if v == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if m, ok := v.(map[string]interface{}); ok &amp;&amp; len(m) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">if coreType, ok := categoriesWithSupplement[catg]; ok </span><span class="cov8" title="1">{
                        coreData, err := coreutil.GetCoreData(ctx, coreType)
                        returnErr = sgtnerror.Append(returnErr, err)
                        if err == nil </span><span class="cov8" title="1">{
                                suppleMap[catg] = coreData.(jsoniter.Any)
                        }</span>
                }
        }
        <span class="cov8" title="1">if len(suppleMap) &gt; 0 </span><span class="cov8" title="1">{
                resultMap["supplemental"] = suppleMap
        }</span>
}

func processFilters(data map[string]interface{}, scopeFilter string) map[string]interface{} <span class="cov8" title="1">{
        if scopeFilter == "" || len(data) == 0 </span><span class="cov8" title="1">{
                return data
        }</span>

        <span class="cov8" title="1">if strings.HasPrefix(scopeFilter, "^") </span><span class="cov8" title="1">{
                tempFilters := strings.TrimSuffix(strings.TrimPrefix(scopeFilter[1:], "("), ")")
                return excludeNodes(data, tempFilters)
        }</span> else<span class="cov8" title="1"> {
                return includeNodes(data, scopeFilter)
        }</span>
}

func excludeNodes(data map[string]interface{}, filters string) map[string]interface{} <span class="cov8" title="1">{
        objxMap := objx.Map(data)
        for _, filter := range strings.Split(filters, common.ParamSep) </span><span class="cov8" title="1">{
                if filter == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">filterParts := strings.Split(filter, scopeFilterSep)
                if partData := data[filterParts[0]]; partData != nil </span><span class="cov8" title="1">{
                        if anyValue, ok := partData.(jsoniter.Any); ok </span><span class="cov8" title="1">{
                                mapData := make(map[string]interface{})
                                anyValue.ToVal(&amp;mapData)
                                data[filterParts[0]] = mapData
                        }</span>
                        <span class="cov8" title="1">parentPath := strings.Join(filterParts[:len(filterParts)-1], objxMapPathSep)
                        parentMap := objxMap.Get(parentPath).ObjxMap()
                        delete(parentMap, filterParts[len(filterParts)-1])</span>
                }
        }
        <span class="cov8" title="1">return data</span>
}
func includeNodes(data map[string]interface{}, filters string) map[string]interface{} <span class="cov8" title="1">{
        oldData, newData := objx.Map(data), objx.Map{}
        for _, filter := range strings.Split(filters, common.ParamSep) </span><span class="cov8" title="1">{
                if filter == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">filterParts := strings.Split(filter, scopeFilterSep)
                if catgData := oldData[filterParts[0]]; catgData != nil </span><span class="cov8" title="1">{
                        if anyValue, ok := catgData.(jsoniter.Any); ok &amp;&amp; len(filterParts) &gt; 1 </span><span class="cov8" title="1">{
                                oldData[filterParts[0]] = anyValue.GetInterface()
                        }</span>
                }

                <span class="cov8" title="1">objxPath := strings.Join(filterParts, objxMapPathSep)
                newData.Set(objxPath, oldData.Get(objxPath).Data())</span>
        }

        <span class="cov8" title="1">for k, v := range oldData </span><span class="cov8" title="1">{
                if _, ok := newData[k]; !ok </span><span class="cov0" title="0">{
                        newData[k] = v
                }</span>
        }

        <span class="cov8" title="1">return newData</span>
}

func addOtherCategories(categories []string, category string) []string <span class="cov8" title="1">{
        if otherCatgs, ok := categoriesNeedOtherCategories[category]; ok </span><span class="cov8" title="1">{
                for _, otherCatg := range otherCatgs </span><span class="cov8" title="1">{
                        if common.Contains(categories, otherCatg) &lt; 0 </span><span class="cov8" title="1">{
                                categories = append(categories, otherCatg)
                        }</span>
                }
        }
        <span class="cov8" title="1">return categories</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">/*
 * Copyright 2022 VMware, Inc.
 * SPDX-License-Identifier: EPL-2.0
 */

package cache

import (
        "context"
        "reflect"

        "sgtnserver/internal/cache"
        "sgtnserver/internal/logger"
        "sgtnserver/modules/cldr"
        "sgtnserver/modules/cldr/dao"
)

var (
        cldrDao = dao.GetDAO()

        coreDataCache cache.Cache
)

type coreCache struct{}

func (coreCache) GetCoreData(ctx context.Context, dataType cldr.CoreDataType, data interface{}) (err error) <span class="cov8" title="1">{
        cacheKey := int(dataType)
        if dataInCache, err := coreDataCache.Get(cacheKey); err == nil </span><span class="cov8" title="1">{
                reflect.ValueOf(data).Elem().Set(reflect.ValueOf(dataInCache))
                return nil
        }</span>

        <span class="cov8" title="1">if err = cldrDao.GetCoreData(ctx, dataType, data); err == nil </span><span class="cov8" title="1">{
                if cacheErr := coreDataCache.Set(cacheKey, reflect.ValueOf(data).Elem().Interface()); cacheErr != nil </span><span class="cov0" title="0">{
                        logger.FromContext(ctx).Error(cacheErr.Error())
                }</span>
        }

        <span class="cov8" title="1">return err</span>
}

func GetCache() coreCache <span class="cov8" title="1">{
        return coreCache{}
}</span>

func init() <span class="cov8" title="1">{
        coreDataCache = cache.NewCache("cldrcore", map[string]interface{}{
                "MaxEntities": int64(cldr.MaxCoreDataSize),
        })
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">/*
 * Copyright 2022 VMware, Inc.
 * SPDX-License-Identifier: EPL-2.0
 */

package coreutil

import (
        "context"
        "strings"

        "sgtnserver/internal/logger"
        "sgtnserver/modules/cldr"
        "sgtnserver/modules/cldr/coreutil/cache"
        "sgtnserver/modules/cldr/dao"

        jsoniter "github.com/json-iterator/go"
)

var (
        LikelySubtagMap           map[string]string
        AvailableLocalesMap       map[string]string
        RegionToLangMap           map[string]string
        LocaleAliasesMap          = map[string]cldr.LocaleAlias{}
        SupplementLanguageDataMap map[string]*cldr.LanguageData
        DefaultContentMap         map[string]string
)

var (
        cachedTypes = map[cldr.CoreDataType]interface{}{}

        EnableCache = true

        dataOrigin coreDataOrigin
)

type coreDataOrigin interface {
        GetCoreData(ctx context.Context, t cldr.CoreDataType, data interface{}) error
}

func GetCoreData(ctx context.Context, t cldr.CoreDataType) (interface{}, error) <span class="cov8" title="1">{
        if dataInPermCache, ok := cachedTypes[t]; ok </span><span class="cov0" title="0">{
                return dataInPermCache, nil
        }</span>

        <span class="cov8" title="1">var data jsoniter.Any
        err := dataOrigin.GetCoreData(ctx, t, &amp;data)
        return data, err</span>
}

func init() <span class="cov8" title="1">{
        if EnableCache </span><span class="cov8" title="1">{
                dataOrigin = cache.GetCache()
        }</span> else<span class="cov0" title="0"> {
                dataOrigin = dao.GetDAO()
        }</span>

        <span class="cov8" title="1">err := dataOrigin.GetCoreData(context.TODO(), cldr.CoreSplmtLikelySubTags, &amp;LikelySubtagMap)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Fatal(err.Error())
        }</span> else<span class="cov8" title="1"> {
                cachedTypes[cldr.CoreSplmtLikelySubTags] = LikelySubtagMap
        }</span>
        <span class="cov8" title="1">err = dataOrigin.GetCoreData(context.TODO(), cldr.CoreAvaLocales, &amp;AvailableLocalesMap)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Fatal(err.Error())
        }</span> else<span class="cov8" title="1"> {
                cachedTypes[cldr.CoreAvaLocales] = AvailableLocalesMap
        }</span>

        <span class="cov8" title="1">err = dataOrigin.GetCoreData(context.TODO(), cldr.RegionToLanguage, &amp;RegionToLangMap)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Fatal(err.Error())
        }</span> else<span class="cov8" title="1"> {
                cachedTypes[cldr.RegionToLanguage] = RegionToLangMap
        }</span>

        <span class="cov8" title="1">var tempAliasMap map[string]cldr.LocaleAlias
        err = dataOrigin.GetCoreData(context.TODO(), cldr.CoreSplmtAlias, &amp;tempAliasMap)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Fatal(err.Error())
        }</span> else<span class="cov8" title="1"> {
                for k, v := range tempAliasMap </span><span class="cov8" title="1">{
                        LocaleAliasesMap[strings.ToLower(k)] = v
                }</span>
                <span class="cov8" title="1">cachedTypes[cldr.CoreSplmtAlias] = LocaleAliasesMap</span>
        }

        <span class="cov8" title="1">err = dataOrigin.GetCoreData(context.TODO(), cldr.CoreSplmtLanguageData, &amp;SupplementLanguageDataMap)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Fatal(err.Error())
        }</span> else<span class="cov8" title="1"> {
                cachedTypes[cldr.CoreSplmtLanguageData] = SupplementLanguageDataMap
        }</span>

        <span class="cov8" title="1">err = dataOrigin.GetCoreData(context.TODO(), cldr.DefaultContent, &amp;DefaultContentMap)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Fatal(err.Error())
        }</span> else<span class="cov8" title="1"> {
                cachedTypes[cldr.DefaultContent] = DefaultContentMap
        }</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">/*
 * Copyright 2022 VMware, Inc.
 * SPDX-License-Identifier: EPL-2.0
 */

package coreutil

import (
        "regexp"
        "strings"

        "sgtnserver/internal/common"
        "sgtnserver/modules/cldr"
)

var localeSplitter = regexp.MustCompile("[-_]")

type Locale struct {
        Language, Scripts, Region string
}

// GetCLDRLocale Query whether locale exists, if not, query defaultContent.json
func GetCLDRLocale(locale string) string <span class="cov8" title="1">{
        localeToProcess := strings.ToLower(strings.ReplaceAll(locale, "_", cldr.LocalePartSep))
        matchedLocale := GetLocaleNameByAliasData(localeToProcess)
        if matchedLocale != "" </span><span class="cov8" title="1">{
                localeToProcess = strings.ToLower(matchedLocale)
        }</span>
        <span class="cov8" title="1">cldrLocale := AvailableLocalesMap[localeToProcess]
        if cldrLocale == "" </span><span class="cov8" title="1">{
                cldrLocale = GetLocaleByDefaultContent(localeToProcess)
        }</span>

        <span class="cov8" title="1">return cldrLocale</span>
}

// GetLocaleByDefaultContent Query defaultContent.json to determine whether
// there is a matching locale, and if so, get the processed result and run
// e.g. fr-FR ==&gt; fr
func GetLocaleByDefaultContent(locale string) string <span class="cov8" title="1">{
        if gotten, ok := DefaultContentMap[locale]; ok </span><span class="cov8" title="1">{
                locale = gotten[0:strings.LastIndex(gotten, cldr.LocalePartSep)]
                return locale
        }</span>
        <span class="cov8" title="1">return ""</span>
}

// GetLocaleByLangReg Get locale by specific Language and Region
func GetLocaleByLangReg(language, region string) string <span class="cov8" title="1">{
        newLang := strings.ReplaceAll(language, "_", cldr.LocalePartSep)
        locale := newLang + cldr.LocalePartSep + region
        cldrLocale := GetCLDRLocale(locale)
        if cldrLocale != "" </span><span class="cov8" title="1">{
                return cldrLocale
        }</span>

        <span class="cov8" title="1">languageParts := strings.Split(newLang, cldr.LocalePartSep)
        size := len(languageParts)
        if size &gt; 1 </span><span class="cov8" title="1">{
                for i := 1; i &lt; size; i++ </span><span class="cov8" title="1">{
                        if strings.EqualFold(region, languageParts[i]) </span><span class="cov8" title="1">{
                                cldrLocale = GetCLDRLocale(newLang)
                                if cldrLocale != "" </span><span class="cov8" title="1">{
                                        return cldrLocale
                                }</span>
                                <span class="cov8" title="1">break</span>
                        }
                }

                <span class="cov8" title="1">grandLanguage := languageParts[0]
                languageScript := languageParts[1]
                if size &gt; 2 </span><span class="cov8" title="1">{
                        locale = grandLanguage + cldr.LocalePartSep + languageScript + cldr.LocalePartSep + region
                        cldrLocale = GetCLDRLocale(locale)
                        if cldrLocale != "" </span><span class="cov8" title="1">{
                                return cldrLocale
                        }</span>
                }

                <span class="cov8" title="1">supplementLanguageData := SupplementLanguageDataMap[grandLanguage]
                if supplementLanguageData != nil </span><span class="cov8" title="1">{
                        scripts := supplementLanguageData.Scripts
                        if len(scripts) != 0 </span><span class="cov8" title="1">{
                                existenceOfScript := false
                                for _, script := range scripts </span><span class="cov8" title="1">{
                                        if strings.EqualFold(languageScript, script) </span><span class="cov8" title="1">{
                                                existenceOfScript = true
                                                break</span>
                                        }
                                }

                                <span class="cov8" title="1">if !existenceOfScript </span><span class="cov8" title="1">{
                                        locale = grandLanguage + cldr.LocalePartSep + region
                                        cldrLocale = GetCLDRLocale(locale)
                                        if cldrLocale != "" </span><span class="cov8" title="1">{
                                                return cldrLocale
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov8" title="1">langFromRegion := RegionToLangMap[strings.ToUpper(region)]
        if langFromRegion != "" </span><span class="cov8" title="1">{
                locale = langFromRegion + cldr.LocalePartSep + region
                return GetCLDRLocale(locale)
        }</span>

        <span class="cov8" title="1">return ""</span>
}

// GetLocaleNameByAliasData Convert a deprecated name to its replacement by aliases.json
func GetLocaleNameByAliasData(oldLocale string) string <span class="cov8" title="1">{
        return LocaleAliasesMap[oldLocale].Replacement
}</span>

// GetPathLocale Parse locale and match cldr locale path: e.g. zh-Hans-CN = &gt; zh-Hans,
// zh-CN = &gt; zh-Hans-CN = &gt; zh-Hans, if no matching item, return zh
func GetPathLocale(locale string) string <span class="cov8" title="1">{
        normalizedLocale := strings.ReplaceAll(strings.ToLower(locale), "_", cldr.LocalePartSep)
        cldrLocale := AvailableLocalesMap[normalizedLocale]
        if cldrLocale != "" </span><span class="cov8" title="1">{
                return cldrLocale
        }</span>

        <span class="cov8" title="1">parts := strings.Split(normalizedLocale, cldr.LocalePartSep)
        switch len(parts) </span>{
        case 3:<span class="cov8" title="1">
                cldrLocale = AvailableLocalesMap[parts[0]+cldr.LocalePartSep+parts[1]] // e.g. zh-Hans
                if cldrLocale == "" </span><span class="cov0" title="0">{
                        cldrLocale = AvailableLocalesMap[parts[0]+cldr.LocalePartSep+parts[2]] // zh-CN
                }</span>
        case 2:<span class="cov8" title="1"> // e.g. zh-Hans or zh-CN =&gt; zh-Hans-CN
                likelySubStr := LikelySubtagMap["und-"+parts[1]] // Get locale ID from Region
                if likelySubStr == "" || strings.Compare(parts[0], strings.Split(likelySubStr, cldr.LocalePartSep)[0]) != 0 </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">if likelySubStr != "" </span><span class="cov8" title="1">{
                        cldrLocale = AvailableLocalesMap[strings.ToLower(likelySubStr)]
                        if cldrLocale == "" </span><span class="cov8" title="1">{
                                likelySubStrArr := strings.Split(likelySubStr, cldr.LocalePartSep)
                                cldrLocale = AvailableLocalesMap[strings.ToLower(likelySubStrArr[0]+cldr.LocalePartSep+likelySubStrArr[1])]
                        }</span>
                }
                <span class="cov8" title="1">if cldrLocale == "" </span><span class="cov0" title="0">{
                        cldrLocale = AvailableLocalesMap[parts[0]]
                }</span>
        }

        <span class="cov8" title="1">return cldrLocale</span>
}

func ParseRegion(parts []string) string <span class="cov8" title="1">{
        region := ""
        switch len(parts) </span>{
        case 2:<span class="cov8" title="1">
                if len(parts[1]) == 2 </span><span class="cov8" title="1">{
                        region = strings.ToUpper(parts[1])
                }</span>
        case 3:<span class="cov0" title="0">
                region = strings.ToUpper(parts[2])</span>
        }

        <span class="cov8" title="1">return region</span>
}

// SplitLocale ...
func SplitLocale(s string) []string <span class="cov8" title="1">{
        if s == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return localeSplitter.Split(s, -1)</span>
}

func ParseLocale(originalLocale string) *Locale <span class="cov8" title="1">{
        parts := SplitLocale(originalLocale)
        if len(parts) &gt; 3 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">locale := Locale{}
        var langData cldr.LanguageData
        for n, p := range parts </span><span class="cov8" title="1">{
                switch n </span>{
                case 0:<span class="cov8" title="1">
                        locale.Language = strings.ToLower(p)
                        if langDataFirst := SupplementLanguageDataMap[locale.Language]; langDataFirst != nil </span><span class="cov8" title="1">{
                                langData.Territories = langDataFirst.Territories
                                langData.Scripts = langDataFirst.Scripts
                        }</span>
                        <span class="cov8" title="1">if langDataSecond := SupplementLanguageDataMap[locale.Language+"-alt-secondary"]; langDataSecond != nil </span><span class="cov8" title="1">{
                                langData.Territories = append(langData.Territories, langDataSecond.Territories...)
                                langData.Scripts = append(langData.Scripts, langDataSecond.Scripts...)
                        }</span>
                        <span class="cov8" title="1">if len(langData.Territories) == 0 &amp;&amp; len(langData.Scripts) == 0 </span><span class="cov8" title="1">{
                                return nil
                        }</span>
                case 1:<span class="cov8" title="1">
                        if i := common.ContainsIgnoreCase(langData.Scripts, p); i &gt;= 0 </span><span class="cov8" title="1">{
                                locale.Scripts = langData.Scripts[i]
                        }</span> else<span class="cov8" title="1"> if j := common.ContainsIgnoreCase(langData.Territories, p); j &gt;= 0 </span><span class="cov8" title="1">{
                                locale.Region = langData.Territories[j]
                                return &amp;locale
                        }</span> else<span class="cov8" title="1"> if matched, _ := regexp.MatchString(`^\d{3}$`, p); matched </span><span class="cov8" title="1">{ // to process number regions
                                locale.Region = p
                                return &amp;locale
                        }</span> else<span class="cov8" title="1"> {
                                return nil
                        }</span>
                case 2:<span class="cov8" title="1">
                        if j := common.ContainsIgnoreCase(langData.Territories, p); j &gt;= 0 </span><span class="cov8" title="1">{
                                locale.Region = langData.Territories[j]
                                return &amp;locale
                        }</span> else<span class="cov8" title="1"> {
                                return nil
                        }</span>
                }
        }

        <span class="cov8" title="1">return &amp;locale</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">/*
 * Copyright 2022 VMware, Inc.
 * SPDX-License-Identifier: EPL-2.0
 */

package dao

import (
        "context"
        "fmt"
        "os"
        "strings"

        "sgtnserver/internal/bindata"
        "sgtnserver/internal/logger"
        "sgtnserver/internal/sgtnerror"
        "sgtnserver/modules/cldr"

        jsoniter "github.com/json-iterator/go"
        "go.uber.org/zap"
)

// this is for contextTransforms, only part of locales have this data. Save result to avoid querying from storage repeatedly
// var nonexistentMap sync.Map

type cldrDAO struct{}

func (cldrDAO) GetCoreData(ctx context.Context, dataType cldr.CoreDataType, data interface{}) error <span class="cov8" title="1">{
        log := logger.FromContext(ctx)
        log.Debug("Read core locale data from storage", zap.String("type", coreDataTypeStrings[dataType]))

        info := getItemInfoOfCoreGroup(dataType)
        if info.filePath == "" </span><span class="cov0" title="0">{
                err := sgtnerror.StatusBadRequest.WithUserMessage(cldr.InvalidDataType, coreDataTypeStrings[dataType])
                log.Error(err.Error())
                return err
        }</span>

        <span class="cov8" title="1">err := sgtnerror.StatusInternalServerError.WrapErrorWithMessage(readDataFromBinary(info.filePath, data, info.jsonPath...), "fail to read cldr data %v", coreDataTypeStrings[dataType])
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err.Error())
        }</span>
        <span class="cov8" title="1">return err</span>
}

func (cldrDAO) GetLocaleData(ctx context.Context, locale, dataType string, data interface{}) error <span class="cov8" title="1">{
        log := logger.FromContext(ctx)
        log.Debug("Read locale data from storage", zap.String("locale", locale), zap.String("type", dataType))

        info := getItemInfoOfLocaleGroup(dataType)
        if info.filePath == "" </span><span class="cov8" title="1">{
                err := sgtnerror.StatusBadRequest.WithUserMessage(cldr.InvalidDataType, dataType)
                log.Error(err.Error())
                return err
        }</span>

        <span class="cov8" title="1">filePath := fmt.Sprintf(info.filePath, locale)
        // if _, ok := nonexistentMap.Load(filePath); ok {
        //         return sgtnerror.StatusNotFound.WithUserMessage("Locale is '%s', type is %v", locale, dataType)
        // }
        err := readDataFromBinary(filePath, data, info.jsonPath...)
        if err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) || strings.Contains(err.Error(), "not found") </span><span class="cov8" title="1">{
                        err = sgtnerror.StatusNotFound.WrapErrorWithMessage(err, filePath)
                        log.Warn(err.Error())
                        // nonexistentMap.Store(filePath, nil)
                }</span> else<span class="cov0" title="0"> {
                        err = sgtnerror.StatusInternalServerError.WrapErrorWithMessage(err, filePath)
                        log.Error(err.Error())
                }</span>
        }
        <span class="cov8" title="1">return err</span>
}

func readDataFromBinary(filePath string, data interface{}, jsonPath ...interface{}) error <span class="cov8" title="1">{
        bts, err := bindata.Asset(filePath)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">v := jsoniter.ConfigDefault.Get(bts, jsonPath...)
        if err := v.LastError(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">v.ToVal(data)

        return nil</span>
}

func GetDAO() cldrDAO <span class="cov8" title="1">{
        return cldrDAO{}
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">/*
 * Copyright 2022-2023 VMware, Inc.
 * SPDX-License-Identifier: EPL-2.0
 */

package dao

import "sgtnserver/modules/cldr"

const cldrBaseFolder = "cldr/"

// Core Data
const (
        LocaleAliasesPath        = cldrBaseFolder + "aliases/aliases.json"
        SupplementalCurrencyPath = cldrBaseFolder + "supplement/currencies.json"
        LanguageDataPath         = cldrBaseFolder + "supplement/languageData.json"
        ParseDataPath            = cldrBaseFolder + "pattern/common/parse.json"
        NumberingSystemsPath     = cldrBaseFolder + "supplement/numbers.json"
        RegionLanguagesMapPath   = cldrBaseFolder + "regionLanguage/regionLanguageMapping.json"
        DefaultContentPath       = cldrBaseFolder + "defaultContent/defaultContent.json"
)

var (
        coreDataInfo = [...]cldrItemInfo{
                cldr.CoreSplmtAlias:            {LocaleAliasesPath, []interface{}{"languageAlias"}},
                cldr.CoreSplmtCurrencyData:     {SupplementalCurrencyPath, nil},
                cldr.CoreSplmtLanguageData:     {LanguageDataPath, []interface{}{"languageData"}},
                cldr.CoreSplmtLikelySubTags:    {ParseDataPath, []interface{}{"likelySubtag"}},
                cldr.CoreSplmtNumberingSystems: {NumberingSystemsPath, []interface{}{}},
                cldr.CoreAvaLocales:            {ParseDataPath, []interface{}{"localePath"}},

                cldr.RegionToLanguage: {RegionLanguagesMapPath, []interface{}{"regionInfo"}},
                cldr.DefaultContent:   {DefaultContentPath, []interface{}{"defaultContent"}},
        }

        coreDataTypeStrings = [...]string{
                cldr.CoreSplmtAlias:            "SplmtAlias",
                cldr.CoreSplmtCurrencyData:     "SplmtCurrency",
                cldr.CoreSplmtLanguageData:     "SplmtLanguage",
                cldr.CoreSplmtLikelySubTags:    "LikelySubTags",
                cldr.CoreSplmtNumberingSystems: "NumberingSystems",
                cldr.CoreAvaLocales:            "AvaLocales",

                cldr.RegionToLanguage: "RegionToLanguage",
                cldr.DefaultContent:   "DefaultContent",
        }
)

// Locale Data
const (
        PatternJSONPath       = cldrBaseFolder + "pattern/common/%s/pattern.json"
        LocaleTerritoriesPath = cldrBaseFolder + "localedata/%s/territories.json"
        LocaleLanguagesPath   = cldrBaseFolder + "localedata/%s/languages.json"
        ContextTransformPath  = cldrBaseFolder + "misc/%s/contextTransforms.json"
        DateFieldsJSONPath    = cldrBaseFolder + "pattern/common/%s/dateFields.json"
        TimeZoneNameJSONPath  = cldrBaseFolder + "pattern/timezone/%s/timeZoneName.json"
)

var localeDataInfo = map[string]cldrItemInfo{
        cldr.PatternDates:        {PatternJSONPath, []interface{}{"categories", "dates"}},
        cldr.PatternNumbers:      {PatternJSONPath, []interface{}{"categories", "numbers"}},
        cldr.PatternPlurals:      {PatternJSONPath, []interface{}{"categories", "plurals"}},
        cldr.PatternMeasurements: {PatternJSONPath, []interface{}{"categories", "measurements"}},
        cldr.PatternCurrencies:   {PatternJSONPath, []interface{}{"categories", "currencies"}},
        cldr.PatternDateFields:   {DateFieldsJSONPath, []interface{}{"dateFields"}},

        cldr.ContextTransform:  {ContextTransformPath, []interface{}{"contextTransforms"}},
        cldr.LocaleLanguages:   {LocaleLanguagesPath, []interface{}{"languages"}},
        cldr.LocaleTerritories: {LocaleTerritoriesPath, []interface{}{}},
        cldr.TimeZoneName:      {TimeZoneNameJSONPath, []interface{}{}},
}

type cldrItemInfo struct {
        filePath string
        jsonPath []interface{}
}

func getItemInfoOfCoreGroup(t cldr.CoreDataType) cldrItemInfo <span class="cov8" title="1">{
        if int(t) &lt; len(coreDataInfo) </span><span class="cov8" title="1">{
                return coreDataInfo[t]
        }</span>
        <span class="cov0" title="0">return cldrItemInfo{}</span>
}

func getItemInfoOfLocaleGroup(t string) cldrItemInfo <span class="cov8" title="1">{
        return localeDataInfo[t]
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">/*
 * Copyright 2022 VMware, Inc.
 * SPDX-License-Identifier: EPL-2.0
 */

package cache

import (
        "context"
        "reflect"
        "sync"
        "time"

        "sgtnserver/internal/cache"
        "sgtnserver/internal/common"
        "sgtnserver/internal/logger"
        "sgtnserver/internal/sgtnerror"
        "sgtnserver/modules/cldr/dao"
)

var (
        cldrDao = dao.GetDAO()

        localeDataCache cache.Cache

        localeDataLocks = sync.Map{}
)

type localeCache struct{}

func (localeCache) GetLocaleData(ctx context.Context, cldrLocale, dataType string, data interface{}) (err error) <span class="cov8" title="1">{
        cacheKey := dataType + ":" + cldrLocale

        // Read from cache
        if dataInCache, e := localeDataCache.Get(cacheKey); e == nil </span><span class="cov8" title="1">{
                reflect.ValueOf(data).Elem().Set(reflect.ValueOf(dataInCache))
                return nil
        }</span>

        // (Read from storage and populate cache) or (wait and read from cache)
        <span class="cov8" title="1">populateCache := func() error </span><span class="cov8" title="1">{
                err = cldrDao.GetLocaleData(ctx, cldrLocale, dataType, data) // Set return error
                if err == nil </span><span class="cov8" title="1">{
                        if cacheErr := localeDataCache.Set(cacheKey, reflect.ValueOf(data).Elem().Interface()); cacheErr != nil </span><span class="cov0" title="0">{
                                logger.FromContext(ctx).Error(cacheErr.Error())
                                return cacheErr
                        }</span>
                }
                <span class="cov8" title="1">return err</span>
        }

        <span class="cov8" title="1">actual, loaded := localeDataLocks.LoadOrStore(cacheKey, make(chan struct{}))
        if !loaded </span><span class="cov8" title="1">{
                defer localeDataLocks.Delete(cacheKey)

                // Don't need to process returned error because values to return have been set in 'populateCache'
                common.DoAndCheck(ctx, actual.(chan struct{}), populateCache, func() </span><span class="cov8" title="1">{ localeDataCache.Wait() }</span>, time.Second)
        } else<span class="cov8" title="1"> { // For the routine waiting for cache population, get from cache
                &lt;-actual.(chan struct{})
                if dataInCache, e := localeDataCache.Get(cacheKey); e == nil </span><span class="cov8" title="1">{
                        reflect.ValueOf(data).Elem().Set(reflect.ValueOf(dataInCache))
                }</span> else<span class="cov0" title="0"> {
                        err = sgtnerror.StatusInternalServerError.WrapErrorWithMessage(e, common.FailToReadCache, cacheKey)
                        logger.FromContext(ctx).Error(err.Error())
                        err = cldrDao.GetLocaleData(ctx, cldrLocale, dataType, data) // Read from storage directly if failing to get from cache
                }</span>
        }

        <span class="cov8" title="1">return</span>
}

func GetCache() localeCache <span class="cov8" title="1">{
        return localeCache{}
}</span>

// InitCLDRCache .
func InitCLDRCache() <span class="cov8" title="1">{
        localeDataCache = cache.NewCache("cldr", map[string]interface{}{
                "MaxEntities": int64(200),
        })
}</span>

func init() <span class="cov8" title="1">{
        InitCLDRCache()
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">/*
 * Copyright 2022 VMware, Inc.
 * SPDX-License-Identifier: EPL-2.0
 */

package localeutil

import (
        "context"
        "strings"

        "sgtnserver/internal/logger"
        "sgtnserver/internal/sgtnerror"
        "sgtnserver/modules/cldr"
        "sgtnserver/modules/cldr/coreutil"
        "sgtnserver/modules/cldr/dao"
        "sgtnserver/modules/cldr/localeutil/cache"
)

var (
        EnableCache = true

        dataOrigin localeDataOrigin
)

type localeDataOrigin interface {
        GetLocaleData(ctx context.Context, locale, dataType string, data interface{}) error
}

func GetLocaleData(ctx context.Context, locale, dataType string, data interface{}) (err error) <span class="cov8" title="1">{
        cldrLocale, ok := coreutil.AvailableLocalesMap[strings.ToLower(locale)]
        if !ok </span><span class="cov8" title="1">{
                err := sgtnerror.StatusBadRequest.WithUserMessage(cldr.InvalidLocale, locale)
                logger.FromContext(ctx).Error(err.Error())
                return err
        }</span>

        <span class="cov8" title="1">return dataOrigin.GetLocaleData(ctx, cldrLocale, dataType, data)</span>
}

func init() <span class="cov8" title="1">{
        if EnableCache </span><span class="cov8" title="1">{
                dataOrigin = cache.GetCache()
        }</span> else<span class="cov0" title="0"> {
                dataOrigin = dao.GetDAO()
        }</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">/*
 * Copyright 2022-2023 VMware, Inc.
 * SPDX-License-Identifier: EPL-2.0
 */

package localeutil

import (
        "context"

        "sgtnserver/internal/sgtnerror"
        "sgtnserver/modules/cldr"
        "sgtnserver/modules/cldr/coreutil"

        jsoniter "github.com/json-iterator/go"
        "golang.org/x/exp/maps"
)

type LocaleTerritories struct {
        Language          string       `json:"language"`
        DefaultRegionCode string       `json:"defaultRegionCode"`
        Territories       jsoniter.Any `json:"territories"`
}

type LocaleTimeZoneNames struct {
        Language      string                 `json:"language"`
        TimeZoneNames map[string]interface{} `json:"timeZoneNames"`
}

func GetPatternData(ctx context.Context, locale string, catg string) (data jsoniter.Any, err error) <span class="cov8" title="1">{
        err = GetLocaleData(ctx, locale, catg, &amp;data)
        return data, err
}</span>

func GetContextTransforms(ctx context.Context, locale string) (map[string]interface{}, error) <span class="cov8" title="1">{
        var data map[string]interface{}
        err := GetLocaleData(ctx, locale, cldr.ContextTransform, &amp;data)
        return data, err
}</span>

func GetLocaleDefaultRegion(ctx context.Context, locale string) (string, error) <span class="cov8" title="1">{
        territories, err := GetLocaleTerritories(ctx, locale)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return territories.DefaultRegionCode, nil</span>
}

func GetLocaleLanguages(ctx context.Context, locale string) (map[string]string, error) <span class="cov8" title="1">{
        var data map[string]string
        err := GetLocaleData(ctx, locale, cldr.LocaleLanguages, &amp;data)
        return data, err
}</span>

func GetLocaleTerritories(ctx context.Context, locale string) (data *LocaleTerritories, err error) <span class="cov8" title="1">{
        data = new(LocaleTerritories)
        err = GetLocaleData(ctx, locale, cldr.LocaleTerritories, data)
        return data, err
}</span>

func GetTerritoriesOfMultipleLocales(ctx context.Context, locales []string) ([]*LocaleTerritories, error) <span class="cov8" title="1">{
        var returnErr *sgtnerror.MultiError

        var err error
        var territoryList []*LocaleTerritories = make([]*LocaleTerritories, 0, len(locales))
        for _, locale := range locales </span><span class="cov8" title="1">{
                var territories *LocaleTerritories
                cldrLocale := coreutil.GetCLDRLocale(locale)
                if cldrLocale == "" </span><span class="cov8" title="1">{
                        err = sgtnerror.StatusBadRequest.WithUserMessage(cldr.InvalidLocale, locale)
                }</span> else<span class="cov8" title="1"> {
                        territories, err = GetLocaleTerritories(ctx, cldrLocale)
                        if err == nil </span><span class="cov8" title="1">{
                                territories.Language = cldrLocale
                                territoryList = append(territoryList, territories)
                        }</span>
                }

                <span class="cov8" title="1">returnErr = sgtnerror.Append(returnErr, err)</span>
        }

        <span class="cov8" title="1">return territoryList, returnErr.ErrorOrNil()</span>
}

func GetTimeZoneNames(ctx context.Context, locale string, defaultTerritory bool) (data *LocaleTimeZoneNames, err error) <span class="cov8" title="1">{
        cldrLocale := coreutil.GetCLDRLocale(locale)
        if cldrLocale == "" </span><span class="cov0" title="0">{
                err = sgtnerror.StatusBadRequest.WithUserMessage(cldr.InvalidLocale, locale)
                return
        }</span>

        <span class="cov8" title="1">data = new(LocaleTimeZoneNames)
        err = GetLocaleData(ctx, cldrLocale, cldr.TimeZoneName, data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if !defaultTerritory </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">const metaZonesKey = "metaZones"
        metaZones := data.TimeZoneNames[metaZonesKey].([]interface{})
        newMetaZones := make([]interface{}, 0, len(metaZones))
        // filter metazones that are not in the default timezone
        for _, metaZone := range metaZones </span><span class="cov8" title="1">{
                if _, ok := metaZone.(map[string]interface{})["mapZones"]; ok </span><span class="cov8" title="1">{
                        newMetaZones = append(newMetaZones, metaZone)
                }</span>
        }
        <span class="cov8" title="1">data = &amp;LocaleTimeZoneNames{Language: data.Language, TimeZoneNames: maps.Clone(data.TimeZoneNames)}
        data.TimeZoneNames[metaZonesKey] = newMetaZones

        return</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">/*
 * Copyright 2022 VMware, Inc.
 * SPDX-License-Identifier: EPL-2.0
 */

package formatting

import (
        "context"
        "time"

        "sgtnserver/internal/logger"
        "sgtnserver/internal/sgtnerror"
        "sgtnserver/modules/cldr"
        "sgtnserver/modules/cldr/coreutil"

        "github.com/xiaochao8/format/date"
        "golang.org/x/text/language"
)

// SimpleFormatDateTime
func SimpleFormatDateTime(ctx context.Context, tm time.Time, pattern, locale string) (string, error) <span class="cov8" title="1">{
        cldrLocale := coreutil.GetCLDRLocale(locale)
        if len(cldrLocale) == 0 </span><span class="cov8" title="1">{
                err := sgtnerror.StatusBadRequest.WithUserMessage(cldr.InvalidLocale, locale)
                logger.FromContext(ctx).Error(err.Error())
                return "", err
        }</span>

        <span class="cov8" title="1">return date.Format(language.Make(cldrLocale), tm, pattern), nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">/*
 * Copyright 2022 VMware, Inc.
 * SPDX-License-Identifier: EPL-2.0
 */

package translation

import (
        "sync"
        "sync/atomic"

        "github.com/emirpasic/gods/sets"
        "github.com/emirpasic/gods/sets/hashset"
        "github.com/emirpasic/gods/sets/linkedhashset"
)

type (
        BundleInfo struct {
                productInfos *sync.Map
        }

        ProductInfo struct {
                name         string
                releaseNames atomic.Value
                releaseInfos *sync.Map
        }

        ReleaseInfo struct {
                name                string
                version             string
                AvailableBundles    sets.Set
                AvailableLocales    sets.Set
                AvailableComponents sets.Set
        }
)

func NewBundleInfo() *BundleInfo <span class="cov8" title="1">{
        return &amp;BundleInfo{productInfos: &amp;sync.Map{}}
}</span>

func newProductInfo(name string) *ProductInfo <span class="cov8" title="1">{
        return &amp;ProductInfo{name: name, releaseInfos: &amp;sync.Map{}}
}</span>

func (i *BundleInfo) GetProductInfo(name string) (*ProductInfo, bool) <span class="cov8" title="1">{
        if product, ok := i.productInfos.Load(name); ok </span><span class="cov8" title="1">{
                return product.(*ProductInfo), true
        }</span>
        <span class="cov8" title="1">return nil, false</span>
}
func (i *BundleInfo) AddProductInfo(name string, info *ProductInfo) (*ProductInfo, bool) <span class="cov8" title="1">{
        product, loaded := i.productInfos.LoadOrStore(name, info)
        return product.(*ProductInfo), loaded
}</span>
func (i *BundleInfo) GetReleaseInfo(name, version string) (*ReleaseInfo, bool) <span class="cov8" title="1">{
        if product, ok := i.GetProductInfo(name); ok </span><span class="cov8" title="1">{
                if release, ok := product.releaseInfos.Load(version); ok </span><span class="cov8" title="1">{
                        return release.(*ReleaseInfo), true
                }</span>
        }
        <span class="cov8" title="1">return nil, false</span>
}
func (i *BundleInfo) AddReleaseInfo(name, version string, info *ReleaseInfo) <span class="cov8" title="1">{
        product, _ := i.AddProductInfo(name, newProductInfo(name))
        product.releaseInfos.Store(version, info)

        existingRelNames := product.GetReleaseNames()
        if !existingRelNames.Contains(version) </span><span class="cov8" title="1">{
                newRelNames := hashset.New(existingRelNames.Values()...)
                newRelNames.Add(version)
                product.releaseNames.Store(newRelNames)
        }</span>
}
func (i *BundleInfo) AddBundle(id *BundleID) <span class="cov8" title="1">{
        releaseInfo, _ := i.GetReleaseInfo(id.Name, id.Version)
        newReleaseInfo := &amp;ReleaseInfo{name: id.Name, version: id.Version}
        if releaseInfo == nil </span><span class="cov8" title="1">{
                newReleaseInfo.AvailableBundles = linkedhashset.New(CompactBundleID{id.Locale, id.Component})
                newReleaseInfo.AvailableLocales = linkedhashset.New(id.Locale)
                newReleaseInfo.AvailableComponents = linkedhashset.New(id.Component)
        }</span> else<span class="cov8" title="1"> {
                bundleID := CompactBundleID{id.Locale, id.Component}
                if releaseInfo.AvailableBundles.Contains(bundleID) </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">newReleaseInfo.AvailableBundles = linkedhashset.New(releaseInfo.AvailableBundles.Values()...)
                newReleaseInfo.AvailableBundles.Add(bundleID)
                newReleaseInfo.AvailableLocales = linkedhashset.New(releaseInfo.AvailableLocales.Values()...)
                newReleaseInfo.AvailableLocales.Add(id.Locale)
                newReleaseInfo.AvailableComponents = linkedhashset.New(releaseInfo.AvailableComponents.Values()...)
                newReleaseInfo.AvailableComponents.Add(id.Component)</span>
        }
        <span class="cov8" title="1">i.AddReleaseInfo(id.Name, id.Version, newReleaseInfo)</span>
}

func (i *BundleInfo) DeleteBundle(id *BundleID) <span class="cov8" title="1">{
        releaseInfo, _ := i.GetReleaseInfo(id.Name, id.Version)
        if releaseInfo == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">compactID := CompactBundleID{id.Locale, id.Component}
        if !releaseInfo.AvailableBundles.Contains(compactID) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">newReleaseInfo := &amp;ReleaseInfo{name: id.Name, version: id.Version}

        newReleaseInfo.AvailableBundles = linkedhashset.New(releaseInfo.AvailableBundles.Values()...)
        newReleaseInfo.AvailableBundles.Remove(compactID)

        newReleaseInfo.AvailableLocales = linkedhashset.New()
        newReleaseInfo.AvailableComponents = linkedhashset.New()
        for _, v := range newReleaseInfo.AvailableBundles.Values() </span><span class="cov8" title="1">{
                bundleID := v.(CompactBundleID)
                newReleaseInfo.AvailableLocales.Add(bundleID.Locale)
                newReleaseInfo.AvailableComponents.Add(bundleID.Component)
        }</span>

        <span class="cov8" title="1">i.AddReleaseInfo(id.Name, id.Version, newReleaseInfo)</span>
}

func (i *BundleInfo) AddBundles(name, version string, ids []CompactBundleID) <span class="cov8" title="1">{
        releaseInfo, _ := i.GetReleaseInfo(name, version)
        newReleaseInfo := &amp;ReleaseInfo{name: name, version: version}
        if releaseInfo == nil </span><span class="cov8" title="1">{
                newReleaseInfo.AvailableBundles = linkedhashset.New()
                newReleaseInfo.AvailableLocales = linkedhashset.New()
                newReleaseInfo.AvailableComponents = linkedhashset.New()
        }</span> else<span class="cov0" title="0"> {
                newReleaseInfo.AvailableBundles = linkedhashset.New(releaseInfo.AvailableBundles.Values()...)
                newReleaseInfo.AvailableLocales = linkedhashset.New(releaseInfo.AvailableLocales.Values()...)
                newReleaseInfo.AvailableComponents = linkedhashset.New(releaseInfo.AvailableComponents.Values()...)
        }</span>

        <span class="cov8" title="1">for _, id := range ids </span><span class="cov8" title="1">{
                newReleaseInfo.AvailableBundles.Add(CompactBundleID{id.Locale, id.Component})
                newReleaseInfo.AvailableLocales.Add(id.Locale)
                newReleaseInfo.AvailableComponents.Add(id.Component)
        }</span>

        <span class="cov8" title="1">i.AddReleaseInfo(name, version, newReleaseInfo)</span>
}

func (i *ProductInfo) GetReleaseNames() sets.Set <span class="cov8" title="1">{
        v := i.releaseNames.Load()
        if v == nil </span><span class="cov8" title="1">{
                return hashset.New()
        }</span>
        <span class="cov8" title="1">return v.(sets.Set)</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">/*
 * Copyright 2022 VMware, Inc.
 * SPDX-License-Identifier: EPL-2.0
 */

package bundleinfo

import (
        "context"
        "sync/atomic"
        "time"

        "sgtnserver/internal/config"
        "sgtnserver/internal/logger"
        "sgtnserver/modules/translation"

        "github.com/emirpasic/gods/sets"
        "go.uber.org/zap"
)

var (
        msgOrigin  translation.MessageOrigin
        bundleInfo atomic.Value
)

func InitBundleInfo(origin translation.MessageOrigin) <span class="cov8" title="1">{
        logger.Log.Debug("Initialize bundle information")
        msgOrigin = origin
        if err := RefreshBundleInfo(context.TODO()); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">if tick := time.Tick(config.Settings.RefreshBundleInterval); tick != nil </span><span class="cov8" title="1">{
                go func() </span><span class="cov8" title="1">{
                        defer func() </span><span class="cov0" title="0">{
                                if err := recover(); err != nil </span><span class="cov0" title="0">{
                                        logger.Log.Error("Panic when refreshing bundle info", zap.Any("error", err))
                                }</span>
                        }()

                        <span class="cov8" title="1">logger.Log.Debug("Start bundle information refresher")
                        for </span><span class="cov8" title="1">{
                                &lt;-tick
                                RefreshBundleInfo(context.TODO())
                        }</span>
                }()
        }
}

func RefreshBundleInfo(ctx context.Context) error <span class="cov8" title="1">{
        info, err := msgOrigin.GetBundleInfo(ctx)
        if err == nil </span><span class="cov8" title="1">{
                bundleInfo.Store(info)
        }</span>

        <span class="cov8" title="1">return err</span>
}

func getBundleInfo() *translation.BundleInfo <span class="cov8" title="1">{
        return bundleInfo.Load().(*translation.BundleInfo)
}</span>
func getReleaseInfo(name, version string) (*translation.ReleaseInfo, bool) <span class="cov8" title="1">{
        return getBundleInfo().GetReleaseInfo(name, version)
}</span>

func AddBundle(id *translation.BundleID) <span class="cov8" title="1">{
        getBundleInfo().AddBundle(id)
}</span>

func DeleteBundle(id *translation.BundleID) <span class="cov8" title="1">{
        getBundleInfo().DeleteBundle(id)
}</span>

func GetAvailableBundles(name, version string) (data sets.Set, ok bool) <span class="cov8" title="1">{
        if r, _ := getReleaseInfo(name, version); r != nil </span><span class="cov8" title="1">{
                return r.AvailableBundles, true
        }</span>
        <span class="cov8" title="1">return nil, false</span>
}

func GetComponentNames(name, version string) (data sets.Set, ok bool) <span class="cov8" title="1">{
        if r, _ := getReleaseInfo(name, version); r != nil </span><span class="cov8" title="1">{
                return r.AvailableComponents, true
        }</span>
        <span class="cov8" title="1">return nil, false</span>
}

func GetLocaleNames(name, version string) (data sets.Set, ok bool) <span class="cov8" title="1">{
        if r, _ := getReleaseInfo(name, version); r != nil </span><span class="cov8" title="1">{
                return r.AvailableLocales, true
        }</span>
        <span class="cov8" title="1">return nil, false</span>
}
func GetReleaseNames(name string) (data sets.Set, ok bool) <span class="cov8" title="1">{
        p, ok := getBundleInfo().GetProductInfo(name)
        if ok </span><span class="cov8" title="1">{
                return p.GetReleaseNames(), true
        }</span>
        <span class="cov8" title="1">return</span>
}

// func IsBundleExist(id *translation.BundleID) bool {
//         if bundles, _ := GetAvailableBundles(id.Name, id.Version); bundles != nil {
//                 return bundles.Contains(translation.CompactBundleID{Locale: id.Locale, Component: id.Component})
//         }
//         return false
// }

func IsProductExist(name string) bool <span class="cov8" title="1">{
        _, ok := getBundleInfo().GetProductInfo(name)
        return ok
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">/*
 * Copyright 2022 VMware, Inc.
 * SPDX-License-Identifier: EPL-2.0
 */

package translation

func GetBundleFilename(locale string) string <span class="cov8" title="1">{
        return BundlePrefix + locale + BundleSuffix
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">/*
 * Copyright 2022 VMware, Inc.
 * SPDX-License-Identifier: EPL-2.0
 */

package dao

import (
        "strings"

        "sgtnserver/internal/config"
        "sgtnserver/internal/logger"
        "sgtnserver/modules/translation"
        "sgtnserver/modules/translation/dao/decorator"
        "sgtnserver/modules/translation/dao/localbundle"
        "sgtnserver/modules/translation/dao/s3bundle"
)

const bundleInLocal = "local"
const bundleInS3 = "s3"

var inst translation.MessageOrigin

func GetInst() translation.MessageOrigin <span class="cov8" title="1">{
        return inst
}</span>

func init() <span class="cov8" title="1">{
        if strings.EqualFold(config.Settings.BundleLocation, bundleInLocal) </span><span class="cov8" title="1">{
                inst = localbundle.NewLocalBundle(config.Settings.LocalBundle.BasePath)
        }</span> else<span class="cov0" title="0"> if strings.EqualFold(config.Settings.BundleLocation, bundleInS3) </span><span class="cov0" title="0">{
                s3config := s3bundle.NewS3Config(
                        config.Settings.S3Bundle.PublicKeyFile,
                        config.Settings.S3Bundle.AccessKey,
                        config.Settings.S3Bundle.SecretKey,
                        config.Settings.S3Bundle.RoleArn,
                        config.Settings.S3Bundle.SessionDuration,
                        config.Settings.S3Bundle.Region)

                inst = s3bundle.NewS3Bundle(
                        config.Settings.S3Bundle.BundleRoot,
                        config.Settings.S3Bundle.BucketName,
                        s3config)
        }</span> else<span class="cov0" title="0"> {
                logger.Log.Fatal("Wrong bundle location: " + config.Settings.BundleLocation)
        }</span>

        <span class="cov8" title="1">inst = decorator.NewDAODecorator(inst)</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">/*
 * Copyright 2022 VMware, Inc.
 * SPDX-License-Identifier: EPL-2.0
 */

package decorator

import (
        "context"
        "fmt"
        "sync"

        "sgtnserver/internal/logger"
        "sgtnserver/modules/translation"
        "sgtnserver/modules/translation/bundleinfo"

        jsoniter "github.com/json-iterator/go"
        "go.uber.org/zap"
)

type decorator struct {
        translation.MessageOrigin
        locks sync.Map
}

func NewDAODecorator(dao translation.MessageOrigin) translation.MessageOrigin <span class="cov8" title="1">{
        return &amp;decorator{MessageOrigin: dao}
}</span>

func (d *decorator) GetBundleInfo(ctx context.Context) (*translation.BundleInfo, error) <span class="cov8" title="1">{
        logger.Log.Debug("Read bundle information from storage")
        return d.MessageOrigin.GetBundleInfo(ctx)
}</span>

func (d *decorator) GetBundle(ctx context.Context, id *translation.BundleID) (*translation.Bundle, error) <span class="cov8" title="1">{
        // Currently it needs to update bundles after service starts, so don't verify here in order to query from storage.
        // if !bundleinfo.IsBundleExist(name, version, locale, component) {
        //         returnErr := sgtnerror.StatusNotFound.WithUserMessage("Translation bundle %s/%s doesn't exist", locale, component)
        //         Log.Error(returnErr)
        //         return nil, returnErr
        // }

        logger.FromContext(ctx).Debug("Read a bundle from storage",
                zap.String(translation.Name, id.Name),
                zap.String(translation.Version, id.Version),
                zap.String(translation.Locale, id.Locale),
                zap.String(translation.Component, id.Component))

        // Lock before reading
        l, _ := d.locks.LoadOrStore(getKey(id), new(sync.RWMutex))
        locker := l.(*sync.RWMutex)
        locker.RLock()
        defer locker.RUnlock()

        b, err := d.MessageOrigin.GetBundle(ctx, id)
        if err == nil </span><span class="cov8" title="1">{
                bundleinfo.AddBundle(id)
        }</span>
        <span class="cov8" title="1">return b, err</span>
}

func (d *decorator) PutBundle(ctx context.Context, bundleData *translation.Bundle) error <span class="cov8" title="1">{
        log := logger.FromContext(ctx)
        log.Debug("Put a bundle",
                zap.String(translation.Name, bundleData.ID.Name),
                zap.String(translation.Version, bundleData.ID.Version),
                zap.String(translation.Locale, bundleData.ID.Locale),
                zap.String(translation.Component, bundleData.ID.Component))

        // Lock before writing
        l, _ := d.locks.LoadOrStore(getKey(&amp;bundleData.ID), new(sync.RWMutex))
        locker := l.(*sync.RWMutex)
        locker.Lock()
        defer locker.Unlock()

        if ce := log.Check(zap.DebugLevel, "Bundle content"); ce != nil </span><span class="cov8" title="1">{
                ce.Write(zap.String("content", bundleData.Messages.ToString()))
        }</span>

        <span class="cov8" title="1">existingBundle, err := d.MessageOrigin.GetBundle(ctx, &amp;bundleData.ID)
        if err == nil </span><span class="cov8" title="1">{
                d.mergeBundle(bundleData, existingBundle)
        }</span>

        <span class="cov8" title="1">err = d.MessageOrigin.PutBundle(ctx, bundleData)
        if err == nil </span><span class="cov8" title="1">{
                bundleinfo.AddBundle(&amp;bundleData.ID)
        }</span>
        <span class="cov8" title="1">return err</span>
}

func (d *decorator) mergeBundle(bundle *translation.Bundle, existingBundle *translation.Bundle) <span class="cov8" title="1">{
        existingMessages, newMessages := make(map[string]string), make(map[string]string)
        existingBundle.Messages.ToVal(&amp;existingMessages)
        bundle.Messages.ToVal(&amp;newMessages)

        for k, v := range newMessages </span><span class="cov8" title="1">{
                existingMessages[k] = v
        }</span>

        <span class="cov8" title="1">marshaled, _ := jsoniter.Marshal(existingMessages)
        bundle.Messages = jsoniter.Get(marshaled)</span>
}

// func (d *decorator) DeleteBundle(ctx context.Context, bundleID *translation.BundleID) error {
//         logger.FromContext(ctx).Debug("Delete a bundle",
//                 zap.String(translation.Name, bundleID.Name),
//                 zap.String(translation.Version, bundleID.Version),
//                 zap.String(translation.Locale, bundleID.Locale),
//                 zap.String(translation.Component, bundleID.Component))

//         // Lock
//         l, _ := d.locks.LoadOrStore(getKey(bundleID), new(sync.RWMutex))
//         locker := l.(*sync.RWMutex)
//         locker.Lock()
//         defer locker.Unlock()

//         err := d.MessageOrigin.DeleteBundle(ctx, bundleID)
//         if err == nil {
//                 bundleinfo.DeleteBundle(bundleID)
//         }
//         return err
// }

func getKey(id *translation.BundleID) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s:%s:%s:%s", id.Name, id.Version, id.Locale, id.Component)
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">/*
 * Copyright 2022 VMware, Inc.
 * SPDX-License-Identifier: EPL-2.0
 */

package localbundle

import (
        "context"
        "io/ioutil"
        "os"
        "path"
        "path/filepath"
        "strings"

        "sgtnserver/internal/logger"
        "sgtnserver/internal/sgtnerror"
        "sgtnserver/modules/translation"

        jsoniter "github.com/json-iterator/go"
        "go.uber.org/zap"
)

var json = jsoniter.ConfigDefault

// LocalBundle ...
type LocalBundle struct {
        BasePath string
}

// NewLocalBundle ...
func NewLocalBundle(p string) *LocalBundle <span class="cov8" title="1">{
        return &amp;LocalBundle{BasePath: p}
}</span>

// GetBundleInfo ...
func (b *LocalBundle) GetBundleInfo(ctx context.Context) (data *translation.BundleInfo, returnErr error) <span class="cov8" title="1">{
        log := logger.FromContext(ctx)
        products, err := ioutil.ReadDir(b.BasePath)
        if err != nil </span><span class="cov0" title="0">{
                returnErr = sgtnerror.StatusInternalServerError.WrapErrorWithMessage(err, translation.FailToGetBundleInfo)
                log.Error(returnErr.Error())
                return nil, returnErr
        }</span>

        <span class="cov8" title="1">bundleInfo := translation.NewBundleInfo()
        for _, product := range products </span><span class="cov8" title="1">{
                if !product.IsDir() </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">productDir := path.Join(b.BasePath, product.Name())
                versions, err := ioutil.ReadDir(productDir)
                if err != nil </span><span class="cov0" title="0">{
                        returnErr = sgtnerror.StatusInternalServerError.WrapErrorWithMessage(err, translation.FailToGetBundleInfo)
                        log.Error(returnErr.Error())
                        return nil, returnErr
                }</span>

                <span class="cov8" title="1">for _, v := range versions </span><span class="cov8" title="1">{
                        if !v.IsDir() </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">verDir := path.Join(productDir, v.Name())
                        components, err := ioutil.ReadDir(verDir)
                        if err != nil </span><span class="cov0" title="0">{
                                returnErr = sgtnerror.StatusInternalServerError.WrapErrorWithMessage(err, translation.FailToGetBundleInfo)
                                log.Error(returnErr.Error())
                                return nil, returnErr
                        }</span>

                        <span class="cov8" title="1">var bundleIDs []translation.CompactBundleID
                        for _, component := range components </span><span class="cov8" title="1">{
                                if !component.IsDir() </span><span class="cov8" title="1">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">componentDir := path.Join(verDir, component.Name())
                                bundles, err := ioutil.ReadDir(componentDir)
                                if err != nil </span><span class="cov0" title="0">{
                                        returnErr = sgtnerror.StatusInternalServerError.WrapErrorWithMessage(err, translation.FailToGetBundleInfo)
                                        log.Error(returnErr.Error())
                                        return nil, returnErr
                                }</span>

                                <span class="cov8" title="1">for _, bundle := range bundles </span><span class="cov8" title="1">{
                                        if bundle.IsDir() </span><span class="cov0" title="0">{
                                                continue</span>
                                        }
                                        <span class="cov8" title="1">bundleName := bundle.Name()
                                        if strings.HasPrefix(bundleName, translation.BundlePrefix) &amp;&amp; strings.HasSuffix(bundleName, translation.BundleSuffix) </span><span class="cov8" title="1">{
                                                locale := bundleName[len(translation.BundlePrefix) : len(bundleName)-len(translation.BundleSuffix)]
                                                bundleIDs = append(bundleIDs, translation.CompactBundleID{Locale: locale, Component: component.Name()})
                                        }</span>
                                }
                        }
                        <span class="cov8" title="1">bundleInfo.AddBundles(product.Name(), v.Name(), bundleIDs)</span>
                }
        }

        <span class="cov8" title="1">return bundleInfo, nil</span>
}

// GetBundle ...
func (b *LocalBundle) GetBundle(ctx context.Context, id *translation.BundleID) (data *translation.Bundle, returnErr error) <span class="cov8" title="1">{
        _, filePath := b.getBundlePath(id)
        contents, err := ioutil.ReadFile(filePath)
        if err == nil </span><span class="cov8" title="1">{
                var bf translation.BundleFile
                if err = json.Unmarshal(contents, &amp;bf); err == nil </span><span class="cov8" title="1">{
                        if !strings.EqualFold(bf.Locale, id.Locale) || !strings.EqualFold(bf.Component, id.Component) </span><span class="cov8" title="1">{
                                logger.FromContext(ctx).Error("Bundle file content is wrong!",
                                        zap.String(translation.Locale, bf.Locale+"?="+id.Locale),
                                        zap.String(translation.Component, bf.Component+"?="+id.Component))
                        }</span>
                        <span class="cov8" title="1">return &amp;translation.Bundle{ID: *id, Messages: bf.Messages}, nil</span>
                }
        }
        <span class="cov8" title="1">if os.IsNotExist(err) </span><span class="cov8" title="1">{
                returnErr = sgtnerror.StatusNotFound.WrapErrorWithMessage(err, translation.FailToReadBundle, id.Name, id.Version, id.Locale, id.Component)
        }</span> else<span class="cov0" title="0"> {
                returnErr = sgtnerror.StatusInternalServerError.WrapErrorWithMessage(err, translation.FailToReadBundle, id.Name, id.Version, id.Locale, id.Component)
        }</span>
        <span class="cov8" title="1">logger.FromContext(ctx).Error(returnErr.Error())
        return nil, returnErr</span>
}

// PutBundle ...
func (b *LocalBundle) PutBundle(ctx context.Context, bundleData *translation.Bundle) (returnErr error) <span class="cov8" title="1">{
        bundle := &amp;translation.BundleFile{Component: bundleData.ID.Component, Locale: bundleData.ID.Locale, Messages: bundleData.Messages}
        bts, err := json.MarshalIndent(bundle, "", "    ")
        if err != nil </span><span class="cov0" title="0">{
                returnErr = sgtnerror.StatusBadRequest.WrapErrorWithMessage(err, translation.WrongBundleContent, bundleData.ID.Name, bundleData.ID.Version, bundleData.ID.Locale, bundleData.ID.Component)
        }</span> else<span class="cov8" title="1"> {
                dirPath, fullPath := b.getBundlePath(&amp;bundleData.ID)
                if err = os.MkdirAll(dirPath, 0755); err == nil </span><span class="cov8" title="1">{
                        err = ioutil.WriteFile(fullPath, bts, 0644)
                }</span>
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        returnErr = sgtnerror.StatusInternalServerError.WrapErrorWithMessage(err, translation.FailToStoreBundle, bundleData.ID.Name, bundleData.ID.Version, bundleData.ID.Locale, bundleData.ID.Component)
                }</span>
        }

        <span class="cov8" title="1">if returnErr != nil </span><span class="cov0" title="0">{
                logger.FromContext(ctx).Error(returnErr.Error())
        }</span>

        <span class="cov8" title="1">return returnErr</span>
}

// DeleteBundle ...
// func (b *LocalBundle) DeleteBundle(ctx context.Context, bundleID *translation.BundleID) error {
//         _, fullPath := b.getBundlePath(bundleID)

//         err := os.Remove(fullPath)
//         if err == nil || os.IsNotExist(err) {
//                 return nil
//         }

//         returnErr := sgtnerror.StatusInternalServerError.WrapError(err)
//         logger.FromContext(ctx).Error(returnErr.Error())
//         return returnErr
// }

func (b *LocalBundle) getBundlePath(id *translation.BundleID) (string, string) <span class="cov8" title="1">{
        fileName := translation.GetBundleFilename(id.Locale)
        dirPath := filepath.Join(b.BasePath, id.Name, id.Version, id.Component)
        fullPath := filepath.Join(dirPath, fileName)

        return dirPath, fullPath
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">/*
 * Copyright 2022 VMware, Inc.
 * SPDX-License-Identifier: EPL-2.0
 */

package s3bundle

import (
        "crypto/rsa"
        "encoding/base64"

        "github.com/buf1024/golib/crypt"
)

func Decrypt(data []byte, publicKey *rsa.PublicKey) (result []byte, err error) <span class="cov0" title="0">{
        decoded, err := Base64Decode(data)
        if err == nil </span><span class="cov0" title="0">{
                result, err = crypt.PublicDecrypt(publicKey, decoded)
        }</span>

        <span class="cov0" title="0">return</span>
}

func Base64Decode(data []byte) ([]byte, error) <span class="cov0" title="0">{
        dst := make([]byte, base64.StdEncoding.DecodedLen(len(data)))
        l, err := base64.StdEncoding.Decode(dst, data)
        return dst[:l], err
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">/*
 * Copyright 2022 VMware, Inc.
 * SPDX-License-Identifier: EPL-2.0
 */

package s3bundle

import (
        "bytes"
        "context"
        "errors"
        "regexp"
        "strings"

        "sgtnserver/internal/logger"
        "sgtnserver/internal/sgtnerror"
        "sgtnserver/modules/translation"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/service/s3"
        "github.com/aws/aws-sdk-go-v2/service/s3/types"
        jsoniter "github.com/json-iterator/go"
        "go.uber.org/zap"
)

var json = jsoniter.ConfigDefault

const slash = "/"

type S3Bundle struct {
        RootPrefix string
        Bucket     *string
        Config     *S3Config
}

// NewS3Bundle ...
func NewS3Bundle(rootPrefix, bucket string, config *S3Config) *S3Bundle <span class="cov0" title="0">{
        // Normalize base path
        if !strings.HasSuffix(rootPrefix, slash) </span><span class="cov0" title="0">{
                rootPrefix += slash
        }</span>
        <span class="cov0" title="0">rootPrefix = regexp.MustCompile(`^(/+|\./)`).ReplaceAllLiteralString(rootPrefix, "")

        // Create bundle instance
        bundle := &amp;S3Bundle{RootPrefix: rootPrefix, Bucket: aws.String(bucket), Config: config}

        // check bucket
        _, err := newS3Client(config).HeadBucket(context.Background(), &amp;s3.HeadBucketInput{Bucket: bundle.Bucket})
        var noSuchBucketErr *types.NoSuchBucket
        if errors.As(err, &amp;noSuchBucketErr) </span><span class="cov0" title="0">{
                err = bundle.createBucket()
                var alreadyOwned *types.BucketAlreadyOwnedByYou
                if !errors.As(err, &amp;alreadyOwned) </span><span class="cov0" title="0">{
                        logger.Log.Fatal(err.Error())
                }</span>
        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                logger.Log.Fatal(err.Error())
        }</span>

        <span class="cov0" title="0">return bundle</span>
}

// GetBundleInfo ...
func (b *S3Bundle) GetBundleInfo(ctx context.Context) (*translation.BundleInfo, error) <span class="cov8" title="1">{
        bundleInfo := translation.NewBundleInfo()

        p := s3.NewListObjectsV2Paginator(GetS3Client(b.Config), &amp;s3.ListObjectsV2Input{Bucket: b.Bucket, Prefix: &amp;b.RootPrefix})
        for p.HasMorePages() </span><span class="cov8" title="1">{
                page, err := p.NextPage(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        wrapErr := sgtnerror.StatusInternalServerError.WrapErrorWithMessage(err, translation.FailToGetBundleInfo)
                        logger.FromContext(ctx).Error(wrapErr.Error())
                        continue</span>
                }

                <span class="cov8" title="1">for _, entry := range page.Contents </span><span class="cov8" title="1">{
                        p := strings.TrimPrefix(*entry.Key, b.RootPrefix)
                        parts := strings.Split(p, slash)
                        if len(parts) &lt; 4 </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">bundleName := parts[3]
                        if strings.HasPrefix(bundleName, translation.BundlePrefix) &amp;&amp;
                                strings.HasSuffix(bundleName, translation.BundleSuffix) </span><span class="cov8" title="1">{
                                locale := bundleName[len(translation.BundlePrefix) : len(bundleName)-len(translation.BundleSuffix)]
                                bundleInfo.AddBundle(&amp;translation.BundleID{
                                        Name:      parts[0],
                                        Version:   parts[1],
                                        Component: parts[2],
                                        Locale:    locale})
                        }</span>
                }
        }

        <span class="cov8" title="1">return bundleInfo, nil</span>
}

// GetBundle ...
func (b *S3Bundle) GetBundle(ctx context.Context, id *translation.BundleID) (bundle *translation.Bundle, returnErr error) <span class="cov8" title="1">{
        input := s3.GetObjectInput{Bucket: b.Bucket, Key: b.GetKey(id)}
        output, err := GetS3Client(b.Config).GetObject(ctx, &amp;input)
        if err == nil </span><span class="cov8" title="1">{
                defer output.Body.Close()

                bf := translation.BundleFile{}
                if err = json.NewDecoder(output.Body).Decode(&amp;bf); err == nil </span><span class="cov8" title="1">{
                        if !strings.EqualFold(bf.Locale, id.Locale) || !strings.EqualFold(bf.Component, id.Component) </span><span class="cov8" title="1">{
                                logger.FromContext(ctx).Error("Bundle file content is wrong!",
                                        zap.String(translation.Locale, bf.Locale+"?="+id.Locale),
                                        zap.String(translation.Component, bf.Component+"?="+id.Component))
                        }</span>
                        <span class="cov8" title="1">return &amp;translation.Bundle{ID: *id, Messages: bf.Messages}, nil</span>
                }
        }

        <span class="cov8" title="1">var noSuchKeyErr *types.NoSuchKey
        if errors.As(err, &amp;noSuchKeyErr) </span><span class="cov8" title="1">{
                returnErr = sgtnerror.StatusNotFound.WrapErrorWithMessage(err, translation.FailToReadBundle, id.Name, id.Version, id.Locale, id.Component)
        }</span> else<span class="cov8" title="1"> {
                returnErr = sgtnerror.StatusInternalServerError.WrapErrorWithMessage(err, translation.FailToReadBundle, id.Name, id.Version, id.Locale, id.Component)
        }</span>
        <span class="cov8" title="1">logger.FromContext(ctx).Error(returnErr.Error())

        return nil, returnErr</span>
}

// PutBundle ...
func (b *S3Bundle) PutBundle(ctx context.Context, bundleData *translation.Bundle) (returnErr error) <span class="cov8" title="1">{
        bundle := &amp;translation.BundleFile{Component: bundleData.ID.Component, Locale: bundleData.ID.Locale, Messages: bundleData.Messages}
        bts, err := json.MarshalIndent(bundle, "", "    ")
        if err != nil </span><span class="cov0" title="0">{
                returnErr = sgtnerror.StatusBadRequest.WrapErrorWithMessage(err, translation.WrongBundleContent, bundleData.ID.Name, bundleData.ID.Version, bundleData.ID.Locale, bundleData.ID.Component)
        }</span> else<span class="cov8" title="1"> {
                input := s3.PutObjectInput{Bucket: b.Bucket, Key: b.GetKey(&amp;bundleData.ID), Body: bytes.NewReader(bts)}
                if _, err = GetS3Client(b.Config).PutObject(ctx, &amp;input); err != nil </span><span class="cov8" title="1">{
                        returnErr = sgtnerror.StatusInternalServerError.WrapErrorWithMessage(err, translation.FailToStoreBundle, bundleData.ID.Name, bundleData.ID.Version, bundleData.ID.Locale, bundleData.ID.Component)
                }</span>
        }

        <span class="cov8" title="1">if returnErr != nil </span><span class="cov8" title="1">{
                logger.FromContext(ctx).Error(returnErr.Error())
        }</span>

        <span class="cov8" title="1">return returnErr</span>
}

// func (b *S3Bundle) DeleteBundle(ctx context.Context, id *translation.BundleID) error {
//         input := s3.DeleteObjectInput{Bucket: b.Bucket, Key: b.GetKey(id)}
//         _, err := GetS3Client(b.Config).DeleteObject(&amp;input)
//         if err == nil {
//                 return nil
//         }

//         returnErr := sgtnerror.StatusInternalServerError.WrapError(err)
//         logger.FromContext(ctx).Error(returnErr.Error())
//         return returnErr
// }

func (b *S3Bundle) GetKey(id *translation.BundleID) *string <span class="cov8" title="1">{
        str := b.RootPrefix +
                id.Name + slash +
                id.Version + slash +
                id.Component + slash +
                translation.GetBundleFilename(id.Locale)
        return aws.String(str)
}</span>

func (b *S3Bundle) createBucket() error <span class="cov0" title="0">{
        createBucketConfig := types.CreateBucketConfiguration{LocationConstraint: types.BucketLocationConstraint(b.Config.region)}
        input := s3.CreateBucketInput{
                Bucket:                    b.Bucket,
                CreateBucketConfiguration: &amp;createBucketConfig}
        _, err := GetS3Client(b.Config).CreateBucket(context.Background(), &amp;input)
        return err
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">/*
 * Copyright 2022 VMware, Inc.
 * SPDX-License-Identifier: EPL-2.0
 */

package s3bundle

import (
        "context"
        "sgtnserver/internal/logger"
        "sync"
        "sync/atomic"
        "time"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/credentials"
        "github.com/aws/aws-sdk-go-v2/service/s3"
        "github.com/aws/aws-sdk-go-v2/service/sts"
        "github.com/aws/aws-sdk-go-v2/service/sts/types"
)

var (
        updateTimeAdvance, _     = time.ParseDuration("60s")
        expirationTimeAdvance, _ = time.ParseDuration("10s")

        clientInst           RoleClient
        clientInstLock       sync.RWMutex
        clientInstUpdateFlag atomic.Value
)

type RoleClient struct {
        *s3.Client
        RoleCredentials *types.Credentials
}

var GetS3Client = func(s3Settings *S3Config) ClientAPI <span class="cov0" title="0">{
        currentInst := readClient()

        diff := time.Until(*currentInst.RoleCredentials.Expiration)
        if diff &gt;= expirationTimeAdvance </span><span class="cov0" title="0">{
                if diff &lt;= updateTimeAdvance &amp;&amp; clientInstUpdateFlag.CompareAndSwap(false, true) </span><span class="cov0" title="0">{
                        go newS3Client(s3Settings)
                }</span>
                <span class="cov0" title="0">return currentInst</span>
        }

        <span class="cov0" title="0">return newS3Client(s3Settings)</span>
}

func newS3Client(s3Settings *S3Config) RoleClient <span class="cov0" title="0">{
        defer clientInstUpdateFlag.Store(false)

        stsClient := sts.New(sts.Options{
                Region:      s3Settings.GetRegion(),
                Credentials: aws.NewCredentialsCache(credentials.NewStaticCredentialsProvider(s3Settings.GetAccessKey(), s3Settings.GetSecretKey(), "")),
        })

        input := &amp;sts.AssumeRoleInput{
                RoleArn:         aws.String(s3Settings.GetRoleArn()),
                RoleSessionName: aws.String("singleton_s3"),
                DurationSeconds: aws.Int32(s3Settings.sessionDuration),
        }

        roleOutput, err := stsClient.AssumeRole(context.Background(), input)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Panic("fail to assume role, " + err.Error())
        }</span>

        <span class="cov0" title="0">creProvider := credentials.NewStaticCredentialsProvider(*roleOutput.Credentials.AccessKeyId,
                *roleOutput.Credentials.SecretAccessKey, *roleOutput.Credentials.SessionToken)

        newInst := RoleClient{
                Client:          s3.New(s3.Options{Region: s3Settings.GetRegion(), Credentials: aws.NewCredentialsCache(creProvider)}),
                RoleCredentials: roleOutput.Credentials,
        }

        writeClient(newInst)

        return newInst</span>
}

func readClient() RoleClient <span class="cov0" title="0">{
        clientInstLock.RLock()
        defer clientInstLock.RUnlock()

        return clientInst
}</span>

func writeClient(inst RoleClient) <span class="cov0" title="0">{
        clientInstLock.Lock()
        defer clientInstLock.Unlock()

        clientInst = inst
}</span>

func init() <span class="cov8" title="1">{
        clientInstUpdateFlag.Store(false)
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">/*
 * Copyright 2022 VMware, Inc.
 * SPDX-License-Identifier: EPL-2.0
 */

package s3bundle

import (
        "crypto/rsa"
        "crypto/x509"
        "io/ioutil"

        "sgtnserver/internal/logger"
)

type (
        S3Config struct {
                publicKeyFile, accessKey, secretKey, roleArn, region string
                sessionDuration int32
        }
)

func NewS3Config(publicKeyFile, accessKey, secretKey, roleArn string, sessionDuration int32, region string) *S3Config <span class="cov8" title="1">{
        config := &amp;S3Config{
                publicKeyFile:   publicKeyFile,
                accessKey:       accessKey,
                secretKey:       secretKey,
                roleArn:         roleArn,
                sessionDuration: sessionDuration,
                region:          region,
        }

        if len(config.publicKeyFile) != 0 </span><span class="cov0" title="0">{
                // Get public key
                fileContent, err := ioutil.ReadFile(config.publicKeyFile)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Fatal(err.Error())
                }</span>

                <span class="cov0" title="0">decodedData, err := Base64Decode(fileContent)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Fatal(err.Error())
                }</span>

                <span class="cov0" title="0">pubKey, err := x509.ParsePKIXPublicKey(decodedData)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Fatal(err.Error())
                }</span>
                <span class="cov0" title="0">rsaPubKey := pubKey.(*rsa.PublicKey)

                // Get AccessKey
                accessKey, err := Decrypt([]byte(config.accessKey), rsaPubKey)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Fatal(err.Error())
                }</span>
                <span class="cov0" title="0">config.accessKey = string(accessKey)

                // Get SecretKey
                secretKey, err := Decrypt([]byte(config.secretKey), rsaPubKey)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Fatal(err.Error())
                }</span>
                <span class="cov0" title="0">config.secretKey = string(secretKey)</span>
        }

        <span class="cov8" title="1">return config</span>
}

func (config *S3Config) GetAccessKey() string <span class="cov0" title="0">{
        return config.accessKey
}</span>

func (config *S3Config) GetSecretKey() string <span class="cov0" title="0">{
        return config.secretKey
}</span>

func (config *S3Config) GetRoleArn() string <span class="cov0" title="0">{
        return config.roleArn
}</span>

func (config *S3Config) GetRegion() string <span class="cov0" title="0">{
        return config.region
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">/*
 * Copyright 2022 VMware, Inc.
 * SPDX-License-Identifier: EPL-2.0
 */

package translation

type TranslationStatus int8

func (s TranslationStatus) IsReady() bool                <span class="cov0" title="0">{ return s == TranslationValid || s == PseudoFound }</span>
func (s TranslationStatus) String() string               <span class="cov0" title="0">{ return statusString[s] }</span>
func (s TranslationStatus) MarshalText() ([]byte, error) <span class="cov8" title="1">{ return []byte(statusString[s]), nil }</span>

const (
        TranslationValid TranslationStatus = iota
        FallbackToEn
        FallbackToSource
        SourceUpdated
        PseudoFound
        PseudoNotFound
)

var statusString = [...]string{
        TranslationValid: "The translation is found and returned",
        FallbackToEn:     "The translation is not found, English found, return the English as translation",
        FallbackToSource: "The translation is not found, English not found, return the received source",
        SourceUpdated:    "The translation is not found or it is not latest, return the received source",
        PseudoFound:      "The pseudo translation is found",
        PseudoNotFound:   "The pseudo translation is not found, return the received source with pseudo tag",
}
</pre>
		
		<pre class="file" id="file43" style="display: none">/*
 * Copyright 2022 VMware, Inc.
 * SPDX-License-Identifier: EPL-2.0
 */

package translationcache

import (
        "context"
        "fmt"
        "sync"
        "time"

        "sgtnserver/internal/cache"
        "sgtnserver/internal/common"
        "sgtnserver/internal/logger"
        "sgtnserver/internal/sgtnerror"
        "sgtnserver/modules/translation"
)

type TransCacheMgr struct {
        DAO   translation.MessageOrigin
        Cache cache.Cache
        locks sync.Map
}

func NewCacheManager(d translation.MessageOrigin, c cache.Cache) *TransCacheMgr <span class="cov8" title="1">{
        return &amp;TransCacheMgr{DAO: d, Cache: c, locks: sync.Map{}}
}</span>

func (c *TransCacheMgr) GetBundleInfo(ctx context.Context) (*translation.BundleInfo, error) <span class="cov8" title="1">{
        return c.DAO.GetBundleInfo(ctx)
}</span>

func (c *TransCacheMgr) GetBundle(ctx context.Context, id *translation.BundleID) (data *translation.Bundle, err error) <span class="cov8" title="1">{
        cacheKey := getCacheKey(id)

        // Read from cache
        if dataInCache, err := c.Cache.Get(cacheKey); err == nil </span><span class="cov8" title="1">{
                return dataInCache.(*translation.Bundle), nil
        }</span>

        // (Read from storage and populate cache) or (wait and read from cache)
        <span class="cov8" title="1">populateCache := func() error </span><span class="cov8" title="1">{
                data, err = c.DAO.GetBundle(ctx, id) // Set return value and error
                if err == nil </span><span class="cov8" title="1">{
                        if cacheErr := c.Cache.Set(cacheKey, data); cacheErr != nil </span><span class="cov0" title="0">{
                                logger.FromContext(ctx).Error(cacheErr.Error())
                                return cacheErr
                        }</span>
                }
                <span class="cov8" title="1">return err</span>
        }

        <span class="cov8" title="1">actual, loaded := c.locks.LoadOrStore(cacheKey, make(chan struct{}))
        if !loaded </span><span class="cov8" title="1">{
                defer c.locks.Delete(cacheKey)

                // Don't need to process returned error because values to return have been set in 'populateCache'
                common.DoAndCheck(ctx, actual.(chan struct{}), populateCache, func() </span><span class="cov8" title="1">{ c.Cache.Wait() }</span>, time.Second)
        } else<span class="cov8" title="1"> { // For the routine waiting for cache population, get from cache
                &lt;-actual.(chan struct{})
                if dataInCache, e := c.Cache.Get(cacheKey); e == nil </span><span class="cov8" title="1">{
                        data = dataInCache.(*translation.Bundle)
                }</span> else<span class="cov8" title="1"> {
                        err = sgtnerror.StatusInternalServerError.WrapErrorWithMessage(e, common.FailToReadCache, cacheKey)
                        logger.FromContext(ctx).Error(err.Error())
                        data, err = c.DAO.GetBundle(ctx, id) // Read from storage directly if failing to get from cache
                }</span>
        }

        <span class="cov8" title="1">return</span>
}

func (c *TransCacheMgr) PutBundle(ctx context.Context, bundleData *translation.Bundle) error <span class="cov8" title="1">{
        err := c.DAO.PutBundle(ctx, bundleData)
        if err == nil </span><span class="cov8" title="1">{
                cacheKey := getCacheKey(&amp;bundleData.ID)
                if _, err := c.Cache.Get(cacheKey); err == nil </span><span class="cov0" title="0">{ // Update cache only when messages have been cached before.
                        if cacheErr := c.Cache.Set(cacheKey, bundleData); cacheErr != nil </span><span class="cov0" title="0">{
                                logger.FromContext(ctx).Error(cacheErr.Error())
                        }</span>
                }
        }

        <span class="cov8" title="1">return err</span>
}

// func (c *TransCacheMgr) DeleteBundle(ctx context.Context, bundleID *translation.BundleID) error {
//         return c.DAO.DeleteBundle(ctx, bundleID)
// }

func getCacheKey(id *translation.BundleID) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s:%s:%s:%s", id.Name, id.Version, id.Locale, id.Component)
}</span>

func (c *TransCacheMgr) ClearCache(ctx context.Context) (err error) <span class="cov8" title="1">{
        log := logger.FromContext(ctx)
        log.Debug("Clear translation cache")
        if err = c.Cache.Clear(); err != nil </span><span class="cov0" title="0">{
                err = sgtnerror.StatusInternalServerError.WrapErrorWithMessage(err, "Fail to clear translation cache")
                log.Error(err.Error())
        }</span>

        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">/*
 * Copyright 2022 VMware, Inc.
 * SPDX-License-Identifier: EPL-2.0
 */

package translationservice

import (
        "context"

        "sgtnserver/modules/translation"

        jsoniter "github.com/json-iterator/go"
)

const (
        pseudoTag = "#@"
)

type PseudoService struct {
        translation.Service
}

// GetMultipleBundles Get translation of multiple bundles
func (ps *PseudoService) GetMultipleBundles(ctx context.Context, name, version, _localeString, componentString string) (*translation.Release, error) <span class="cov8" title="1">{
        releaseData, err := ps.Service.GetMultipleBundles(ctx, name, version, translation.Latest, componentString)
        for i, bundle := range releaseData.Bundles </span><span class="cov8" title="1">{
                releaseData.Bundles[i] = addPseudoTag(*bundle)
        }</span>
        <span class="cov8" title="1">releaseData.Pseudo = true

        return releaseData, err</span>
}

// GetBundle ...
func (ps *PseudoService) GetBundle(ctx context.Context, id *translation.BundleID) (*translation.Bundle, error) <span class="cov8" title="1">{
        id.Locale = translation.Latest
        bundle, err := ps.Service.GetBundle(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return addPseudoTag(*bundle), nil</span>
}

// GetStringWithSource ...
func (ps *PseudoService) GetStringWithSource(ctx context.Context, id *translation.MessageID, source string) (map[string]interface{}, error) <span class="cov8" title="1">{
        id.Locale = translation.Latest
        result := map[string]interface{}{
                "productName": id.Name,
                "version":     id.Version,
                "locale":      id.Locale,
                "component":   id.Component,
                "key":         id.Key,
                "source":      source,
                "pseudo":      true}

        if stringMessage, err := ps.GetString(ctx, id); err == nil </span><span class="cov8" title="1">{
                result["translation"] = pseudoTag + stringMessage.Translation + pseudoTag
                result["status"] = translation.PseudoFound
        }</span> else<span class="cov8" title="1"> {
                result["translation"] = "@@" + source + "@@"
                result["status"] = translation.PseudoNotFound
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

//GetPseudoService ...
func GetPseudoService(service translation.Service) translation.Service <span class="cov8" title="1">{
        return &amp;PseudoService{service}
}</span>

func addPseudoTag(bundle translation.Bundle) *translation.Bundle <span class="cov8" title="1">{
        // store messages into a map
        messages := make(map[string]string)
        bundle.Messages.ToVal(&amp;messages)

        // add pseudo tags
        for key, value := range messages </span><span class="cov8" title="1">{
                messages[key] = pseudoTag + value + pseudoTag
        }</span>

        // marshal messages
        <span class="cov8" title="1">marshaled, _ := jsoniter.Marshal(messages)
        return &amp;translation.Bundle{ID: bundle.ID, Pseudo: true, Messages: jsoniter.Get(marshaled)}</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">/*
 * Copyright 2022-2023 VMware, Inc.
 * SPDX-License-Identifier: EPL-2.0
 */

package translationservice

import (
        "context"
        "strings"

        "sgtnserver/internal/cache"
        "sgtnserver/internal/common"
        "sgtnserver/internal/config"
        "sgtnserver/internal/logger"
        "sgtnserver/internal/sgtnerror"
        "sgtnserver/modules/translation"
        "sgtnserver/modules/translation/bundleinfo"
        "sgtnserver/modules/translation/dao"
        "sgtnserver/modules/translation/translationcache"

        "github.com/fatih/structs"
        jsoniter "github.com/json-iterator/go"
        "go.uber.org/zap"
)

type Service struct {
        msgOrigin translation.MessageOrigin
}

// GetAvailableComponents ...
func (ts Service) GetAvailableComponents(ctx context.Context, name, version string) (data []string, returnErr error) <span class="cov8" title="1">{
        log := logger.FromContext(ctx)
        log.Debug("Get supported component list", zap.String(translation.Name, name), zap.String(translation.Version, version))
        components, ok := bundleinfo.GetComponentNames(name, version)
        if !ok </span><span class="cov8" title="1">{
                returnErr = sgtnerror.StatusNotFound.WithUserMessage(translation.ReleaseNonexistent, name, version)
                log.Error(returnErr.Error())
                return nil, returnErr
        }</span>

        <span class="cov8" title="1">return convertSetToList(components), nil</span>
}

// GetAvailableLocales ...
func (ts Service) GetAvailableLocales(ctx context.Context, name, version string) (data []string, returnErr error) <span class="cov8" title="1">{
        log := logger.FromContext(ctx)
        log.Debug("Get supported locale list", zap.String(translation.Name, name), zap.String(translation.Version, version))
        locales, ok := bundleinfo.GetLocaleNames(name, version)
        if !ok </span><span class="cov8" title="1">{
                returnErr = sgtnerror.StatusNotFound.WithUserMessage(translation.ReleaseNonexistent, name, version)
                log.Error(returnErr.Error())
                return nil, returnErr
        }</span>

        <span class="cov8" title="1">for _, e := range locales.Values() </span><span class="cov8" title="1">{
                locale := e.(string)
                if locale != translation.Latest </span><span class="cov8" title="1">{
                        data = append(data, locale)
                }</span>
        }
        <span class="cov8" title="1">return data, nil</span>
}

// GetAvailableBundles ...
func (ts Service) GetAvailableBundles(ctx context.Context, name, version string) (data []translation.CompactBundleID, returnErr error) <span class="cov8" title="1">{
        log := logger.FromContext(ctx)
        log.Debug("Get available bundle IDs", zap.String(translation.Name, name), zap.String(translation.Version, version))
        IDs, ok := bundleinfo.GetAvailableBundles(name, version)
        if !ok </span><span class="cov8" title="1">{
                returnErr = sgtnerror.StatusNotFound.WithUserMessage(translation.ReleaseNonexistent, name, version)
                log.Error(returnErr.Error())
                return nil, returnErr
        }</span>
        <span class="cov8" title="1">values := IDs.Values()
        data = make([]translation.CompactBundleID, 0, len(values))
        for _, v := range values </span><span class="cov8" title="1">{
                id := v.(translation.CompactBundleID)
                if id.Locale != translation.Latest </span><span class="cov8" title="1">{
                        data = append(data, id)
                }</span>
        }
        <span class="cov8" title="1">return data, nil</span>
}

// GetMultipleBundles Get translation of multiple bundles
func (ts Service) GetMultipleBundles(ctx context.Context, name, version, localeString, componentString string) (*translation.Release, error) <span class="cov8" title="1">{
        log := logger.FromContext(ctx)
        log.Debug("Get bundles", zap.String(translation.Name, name), zap.String(translation.Version, version),
                zap.String("locales", localeString), zap.String("components", componentString))

        var bundleIDs = []translation.CompactBundleID{}
        var err error
        if localeString == "" &amp;&amp; componentString == "" </span><span class="cov8" title="1">{
                bundleIDs, err = ts.GetAvailableBundles(ctx, name, version)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
        } else<span class="cov8" title="1"> {
                var components, locales []string
                if localeString != "" </span><span class="cov8" title="1">{
                        locales = PickupLocales(name, version, strings.Split(localeString, common.ParamSep))
                }</span> else<span class="cov8" title="1"> {
                        locales, err = ts.GetAvailableLocales(ctx, name, version)
                        if err != nil </span><span class="cov8" title="1">{
                                err = sgtnerror.StatusNotFound.WithUserMessage(translation.ReleaseNonexistent, name, version)
                                log.Error(err.Error())
                                return nil, err
                        }</span>
                }
                <span class="cov8" title="1">if componentString != "" </span><span class="cov8" title="1">{
                        components = strings.Split(componentString, common.ParamSep)
                }</span> else<span class="cov8" title="1"> {
                        components, err = ts.GetAvailableComponents(ctx, name, version)
                        if err != nil </span><span class="cov8" title="1">{
                                err = sgtnerror.StatusNotFound.WithUserMessage(translation.ReleaseNonexistent, name, version)
                                log.Error(err.Error())
                                return nil, err
                        }</span>
                }

                <span class="cov8" title="1">for _, comp := range components </span><span class="cov8" title="1">{
                        for _, locale := range locales </span><span class="cov8" title="1">{
                                bundleIDs = append(bundleIDs, translation.CompactBundleID{Locale: locale, Component: comp})
                        }</span>
                }
        }

        <span class="cov8" title="1">bundles, err := ts.getMultipleBundles(ctx, name, version, bundleIDs)
        return &amp;translation.Release{Name: name, Version: version, Bundles: bundles}, err</span>
}

func (ts Service) getMultipleBundles(ctx context.Context, name, version string, bundleIDs []translation.CompactBundleID) (data []*translation.Bundle, err error) <span class="cov8" title="1">{
        var returnErr *sgtnerror.MultiError
        for _, id := range bundleIDs </span><span class="cov8" title="1">{
                b, err := ts.msgOrigin.GetBundle(ctx, &amp;translation.BundleID{Name: name, Version: version, Locale: id.Locale, Component: id.Component})
                if err == nil </span><span class="cov8" title="1">{
                        data = append(data, b)
                }</span>
                <span class="cov8" title="1">returnErr = sgtnerror.Append(returnErr, err)</span>
        }

        <span class="cov8" title="1">return data, returnErr.ErrorOrNil()</span>
}

// GetBundle ...
func (ts Service) GetBundle(ctx context.Context, id *translation.BundleID) (*translation.Bundle, error) <span class="cov8" title="1">{
        name, version, locale, component := id.Name, id.Version, id.Locale, id.Component
        logger.FromContext(ctx).Debug("Get a bundle", zap.String(translation.Name, name), zap.String(translation.Version, version),
                zap.String(translation.Locale, locale), zap.String(translation.Component, component))

        id.Locale = PickupLocales(name, version, []string{locale})[0]
        return ts.msgOrigin.GetBundle(ctx, id)
}</span>

// GetStrings ...
func (ts Service) GetStrings(ctx context.Context, id *translation.BundleID, keys []string) (*translation.Bundle, error) <span class="cov8" title="1">{
        name, version, locale, component := id.Name, id.Version, id.Locale, id.Component
        logger.FromContext(ctx).Debug("Get translations of multiple keys", zap.String(translation.Name, name), zap.String(translation.Version, version),
                zap.String(translation.Locale, locale), zap.String(translation.Component, component), zap.Strings("keys", keys))

        id.Locale = PickupLocales(name, version, []string{locale})[0]
        bundle, err := ts.msgOrigin.GetBundle(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var returnErr *sgtnerror.MultiError
        allMsgs := make(map[string]jsoniter.Any)
        bundle.Messages.ToVal(&amp;allMsgs)
        messagesToReturn := make(map[string]jsoniter.Any, len(keys))
        for _, key := range keys </span><span class="cov8" title="1">{
                msg := allMsgs[key]
                if msg == nil </span><span class="cov8" title="1">{
                        returnErr = sgtnerror.Append(returnErr, sgtnerror.StatusNotFound.WithUserMessage(translation.KeyNotFound, key))
                }</span> else<span class="cov8" title="1"> {
                        messagesToReturn[key] = msg
                        returnErr = sgtnerror.Append(returnErr, nil)
                }</span>
        }
        <span class="cov8" title="1">marshaled, _ := jsoniter.Marshal(messagesToReturn)
        return &amp;translation.Bundle{ID: bundle.ID, Messages: jsoniter.Get(marshaled)}, returnErr.ErrorOrNil()</span>
}

// GetString ...
func (ts Service) GetString(ctx context.Context, id *translation.MessageID) (*translation.StringMessage, error) <span class="cov8" title="1">{
        b, err := ts.GetBundle(ctx, &amp;translation.BundleID{Name: id.Name, Version: id.Version, Locale: id.Locale, Component: id.Component})
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">anyValue := b.Messages.Get(id.Key)
        if anyValue.LastError() == nil </span><span class="cov8" title="1">{
                return &amp;translation.StringMessage{
                                Name:        id.Name,
                                Version:     id.Version,
                                Locale:      b.ID.Locale,
                                Component:   id.Component,
                                Key:         id.Key,
                                Translation: anyValue.ToString()},
                        nil
        }</span>

        <span class="cov8" title="1">return nil, sgtnerror.StatusNotFound.WrapErrorWithMessage(translation.ErrStringNotFound, "Fail to get translation for key '%s'", id.Key)</span>
        // Log.Debug(returnErr)//Don't log because of key is very small granularity
}

func (ts Service) GetStringWithSource(ctx context.Context, id *translation.MessageID, source string) (result map[string]interface{}, returnErr error) <span class="cov8" title="1">{
        var stringTrans, locale string
        var status translation.TranslationStatus
        msg, err := ts.GetString(ctx, id)

        msgEn, errEn := msg, err
        if id.Locale != translation.EnLocale </span><span class="cov8" title="1">{
                idEn := *id
                idEn.Locale = translation.EnLocale
                msgEn, errEn = ts.GetString(ctx, &amp;idEn)
        }</span>
        <span class="cov8" title="1">if source != "" </span><span class="cov0" title="0">{
                if errEn != nil || msgEn.Translation != source </span><span class="cov0" title="0">{
                        stringTrans, locale, status = source, translation.EnLocale, translation.SourceUpdated
                }</span> else<span class="cov0" title="0"> {
                        if err == nil </span><span class="cov0" title="0">{
                                stringTrans, locale, status = msg.Translation, msg.Locale, translation.TranslationValid
                        }</span> else<span class="cov0" title="0"> {
                                if errEn == nil </span><span class="cov0" title="0">{
                                        stringTrans, locale, status = msgEn.Translation, msgEn.Locale, translation.FallbackToEn
                                }</span> else<span class="cov0" title="0"> {
                                        stringTrans, locale, status = source, translation.EnLocale, translation.FallbackToSource
                                }</span>
                        }
                }
        } else<span class="cov8" title="1"> {
                if err == nil </span><span class="cov8" title="1">{
                        stringTrans, locale, status = msg.Translation, msg.Locale, translation.TranslationValid
                }</span> else<span class="cov8" title="1"> {
                        if errEn == nil </span><span class="cov8" title="1">{
                                stringTrans, locale, status = msgEn.Translation, msgEn.Locale, translation.FallbackToEn
                        }</span> else<span class="cov8" title="1"> {
                                return nil, err
                        }</span>
                }
        }

        <span class="cov8" title="1">return map[string]interface{}{
                        "productName": id.Name,
                        "version":     id.Version,
                        "locale":      locale,
                        "component":   id.Component,
                        "key":         id.Key,
                        "translation": stringTrans,
                        "source":      source,
                        "status":      status},
                nil</span>
}

// PutBundles ...
func (ts Service) PutBundles(ctx context.Context, bundleData []*translation.Bundle) error <span class="cov8" title="1">{
        logger.FromContext(ctx).Debug("Put bundles")
        var returnErr *sgtnerror.MultiError
        for _, bd := range bundleData </span><span class="cov8" title="1">{
                err := ts.msgOrigin.PutBundle(ctx, bd)
                returnErr = sgtnerror.Append(returnErr, err)
        }</span>

        <span class="cov8" title="1">return returnErr.ErrorOrNil()</span>
}

// DeleteBundle ...
// func (ts Service) DeleteBundle(ctx context.Context, bundleID *translation.BundleID) error {
//         logger.FromContext(ctx).Debug("Delete a bundle", zap.Any("id", bundleID))
//         return ts.msgOrigin.DeleteBundle(ctx, bundleID)
// }

// DeleteString ...
// func (ts Service) DeleteString(ctx context.Context, name, version, locale, component, key string) error {
//         log := logger.FromContext(ctx)
//         log.Debug("Delete a string", zap.String(translation.Name, name),
//                 zap.String(translation.Version, version), zap.String(translation.Locale, locale),
//                 zap.String(translation.Component, component), zap.String("key", key))

//         bundle, err := ts.msgOrigin.GetBundle(ctx, &amp;translation.BundleID{Name: name,
//                 Version: version, Locale: locale, Component: component})
//         if err != nil {
//                 return err
//         }

//         messages, _ := bundle.Messages.GetInterface().(map[string]interface{})
//         if messages == nil {
//                 returnErr := sgtnerror.StatusInternalServerError.WrapError(errors.New("bundle file content is wrong"))
//                 log.Error(returnErr.Error())
//                 return returnErr
//         }
//         if _, ok := messages[key]; !ok {
//                 return nil
//         }

//         delete(messages, key)
//         bts, err := json.MarshalIndent(messages, "", "    ")
//         if err != nil {
//                 returnErr := sgtnerror.StatusInternalServerError.WrapError(err)
//                 log.Error(returnErr.Error())
//                 return returnErr
//         }

//         bundle.Messages = json.Get(bts)
//         return ts.msgOrigin.PutBundle(ctx, bundle)
// }

func (ts Service) ClearCache(ctx context.Context) (err error) <span class="cov8" title="1">{
        if m, ok := ts.msgOrigin.(*translationcache.TransCacheMgr); ok </span><span class="cov8" title="1">{
                err = m.ClearCache(ctx)
        }</span>
        <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                err = bundleinfo.RefreshBundleInfo(ctx)
        }</span>

        <span class="cov8" title="1">return</span>
}

func (ts Service) GetTranslationStatus(ctx context.Context, id *translation.BundleID) (map[string]interface{}, error) <span class="cov0" title="0">{
        logger.FromContext(ctx).Debug("Get a bundle's translation status", zap.String(translation.Name, id.Name), zap.String(translation.Version, id.Version),
                zap.String(translation.Locale, id.Locale), zap.String(translation.Component, id.Component))

        id.Locale = PickupLocales(id.Name, id.Version, []string{id.Locale})[0]

        const ready, notready = "1", "0"

        translationData, tErr := ts.GetBundle(ctx, id)
        if tErr != nil </span><span class="cov0" title="0">{
                return nil, sgtnerror.TranslationNotReady
        }</span>

        <span class="cov0" title="0">latestID := *id
        latestID.Locale = translation.Latest
        latestData, latestErr := ts.GetBundle(ctx, &amp;latestID)
        if latestErr != nil </span><span class="cov0" title="0">{
                return nil, sgtnerror.TranslationReady
        }</span>

        <span class="cov0" title="0">var enErr error
        var enData = translationData
        if translationData.ID.Locale != translation.EnLocale </span><span class="cov0" title="0">{
                enID := *id
                enID.Locale = translation.EnLocale
                enData, enErr = ts.GetBundle(ctx, &amp;enID)
                if enErr != nil </span><span class="cov0" title="0">{
                        return nil, sgtnerror.TranslationNotReady
                }</span>
        }

        <span class="cov0" title="0">var latestMessages, enMessages map[string]string
        latestData.Messages.ToVal(&amp;latestMessages)
        enData.Messages.ToVal(&amp;enMessages)

        var result = make(map[string]interface{}, len(latestMessages))
        var err = sgtnerror.TranslationReady
        for k, latestValue := range latestMessages </span><span class="cov0" title="0">{
                if latestValue == enMessages[k] </span><span class="cov0" title="0">{
                        result[k] = ready
                }</span> else<span class="cov0" title="0"> {
                        result[k] = notready
                        err = sgtnerror.TranslationNotReady
                }</span>
        }

        <span class="cov0" title="0">return result, err</span>
}

var service Service

func newService() Service <span class="cov8" title="1">{
        logger.Log.Debug("Initialize translation service")

        origin := dao.GetInst()
        if config.Settings.Cache.Enable </span><span class="cov8" title="1">{
                origin = translationcache.NewCacheManager(origin, cache.NewCache("translation", structs.Map(config.Settings.Cache)))
        }</span>

        <span class="cov8" title="1">bundleinfo.InitBundleInfo(origin)
        return Service{origin}</span>
}

func GetService() Service <span class="cov8" title="1">{
        return service
}</span>

func init() <span class="cov8" title="1">{
        service = newService()

        initLocaleMap()

        initAllowedProducts()
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">/*
 * Copyright 2022-2023 VMware, Inc.
 * SPDX-License-Identifier: EPL-2.0
 */

package translationservice

import (
        "strconv"
        "strings"

        "sgtnserver/internal/bindata"
        "sgtnserver/internal/config"
        "sgtnserver/internal/logger"
        "sgtnserver/modules/cldr"
        "sgtnserver/modules/cldr/coreutil"
        "sgtnserver/modules/translation/bundleinfo"

        mapset "github.com/deckarep/golang-set/v2"
        "github.com/emirpasic/gods/sets"
        jsoniter "github.com/json-iterator/go"
        "go.uber.org/zap"
        "gopkg.in/yaml.v3"
)

var json = jsoniter.ConfigDefault

var localeMap map[string]string

func PickupLocales(name, version string, locales []string) []string <span class="cov8" title="1">{
        localeCandidates, ok := bundleinfo.GetLocaleNames(name, version)
        if !ok </span><span class="cov8" title="1">{
                return locales
        }</span>

        <span class="cov8" title="1">pickedLocales := make([]string, len(locales))
        for i, locale := range locales </span><span class="cov8" title="1">{
                if pickedLocale := PickupLocaleFromList(localeCandidates, locale); pickedLocale != "" </span><span class="cov8" title="1">{
                        pickedLocales[i] = pickedLocale
                }</span> else<span class="cov8" title="1"> {
                        pickedLocales[i] = locale
                }</span>
        }
        <span class="cov8" title="1">return pickedLocales</span>
}

func PickupLocaleFromList(locales sets.Set, preferredLocale string) string <span class="cov8" title="1">{
        if locales.Contains(preferredLocale) </span><span class="cov8" title="1">{
                return preferredLocale
        }</span>

        <span class="cov8" title="1">originalLocale := strings.ReplaceAll(preferredLocale, "_", cldr.LocalePartSep)
        if v, ok := localeMap[strings.ToLower(originalLocale)]; ok </span><span class="cov8" title="1">{
                originalLocale = v
        }</span>

        <span class="cov8" title="1">normalizedOriginalLocale := coreutil.ParseLocale(originalLocale)
        if normalizedOriginalLocale == nil </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">chosenLocale := ""
        for _, locale := range locales.Values() </span><span class="cov8" title="1">{
                inLoopLocale := locale.(string)
                if strings.EqualFold(originalLocale, inLoopLocale) </span><span class="cov8" title="1">{
                        return inLoopLocale
                }</span>

                <span class="cov8" title="1">normalizedInLoopLocale := coreutil.ParseLocale(inLoopLocale)
                if normalizedInLoopLocale == nil </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if strings.EqualFold(normalizedInLoopLocale.Language, normalizedOriginalLocale.Language) </span><span class="cov8" title="1">{
                        chosenLocale = normalizedInLoopLocale.Language
                        script := normalizedInLoopLocale.Scripts
                        if script != "" &amp;&amp; strings.EqualFold(script, normalizedOriginalLocale.Scripts) </span><span class="cov8" title="1">{
                                chosenLocale = normalizedOriginalLocale.Language + cldr.LocalePartSep + script
                        }</span>
                        <span class="cov8" title="1">region := normalizedInLoopLocale.Region
                        if region != "" &amp;&amp; strings.EqualFold(region, normalizedOriginalLocale.Region) </span><span class="cov8" title="1">{
                                chosenLocale = chosenLocale + cldr.LocalePartSep + region
                        }</span>
                }
        }

        <span class="cov8" title="1">return chosenLocale</span>
}

// PickupVersion version fallback
func PickupVersion(name, desiredVersion string) string <span class="cov8" title="1">{
        versions, ok := bundleinfo.GetReleaseNames(name)
        if !ok </span><span class="cov8" title="1">{
                return desiredVersion
        }</span>
        <span class="cov8" title="1">if versions.Contains(desiredVersion) </span><span class="cov8" title="1">{
                return desiredVersion
        }</span>

        <span class="cov8" title="1">desiredVersionObj := newVersion(desiredVersion)
        var chosen *Version
        for _, v := range versions.Values() </span><span class="cov8" title="1">{
                vo := newVersion(v.(string))
                if vo.Less(desiredVersionObj) &lt;= 0 </span><span class="cov8" title="1">{
                        if chosen == nil </span><span class="cov8" title="1">{
                                chosen = vo
                        }</span> else<span class="cov8" title="1"> if chosen.Less(vo) &lt; 0 </span><span class="cov8" title="1">{
                                chosen = vo
                        }</span>
                }
        }
        <span class="cov8" title="1">if chosen != nil </span><span class="cov8" title="1">{
                return chosen.version
        }</span>
        <span class="cov8" title="1">return desiredVersion</span>
}

var allowedProducts = map[string]mapset.Set[string]{}

func initAllowedProducts() <span class="cov8" title="1">{
        allowSettings := map[string][]string{}
        err := yaml.Unmarshal([]byte(config.Settings.AllowedProducts), &amp;allowSettings)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Fatal(err.Error())
        }</span>
        <span class="cov8" title="1">for product, versions := range allowSettings </span><span class="cov8" title="1">{
                if !bundleinfo.IsProductExist(product) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">newProductVersions := mapset.NewSet[string]()
                allowedProducts[product] = newProductVersions
                if allExistingVersions, ok := bundleinfo.GetReleaseNames(product); ok </span><span class="cov8" title="1">{
                        for _, version := range versions </span><span class="cov8" title="1">{
                                if version == "*" </span><span class="cov8" title="1">{
                                        for _, v := range allExistingVersions.Values() </span><span class="cov8" title="1">{
                                                newProductVersions.Add(v.(string))
                                        }</span>
                                        <span class="cov8" title="1">break</span>
                                }

                                <span class="cov8" title="1">if allExistingVersions.Contains(version) </span><span class="cov8" title="1">{
                                        newProductVersions.Add(version)
                                }</span>
                        }
                }
        }
}

// func IsReleaseAllowed(name, version string) bool {
//         if versions, ok := allowedProducts[name]; ok {
//                 if versions.Contains(version) {
//                         return true
//                 }
//         }

//         return false
// }

func IsProductAllowed(name string) bool <span class="cov8" title="1">{
        if _, ok := allowedProducts[name]; ok </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">return false</span>
}

func initLocaleMap() <span class="cov8" title="1">{
        logger.Log.Debug("Initialize locale mapping")

        const localeMapFile = "localemap.json"
        bts, err := bindata.Asset(localeMapFile)
        if err == nil </span><span class="cov8" title="1">{
                err = json.Unmarshal(bts, &amp;localeMap)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("Failed to read locale mapping file", zap.String("file", localeMapFile), zap.Error(err))
        }</span>
}

func convertSetToList(s sets.Set) (result []string) <span class="cov8" title="1">{
        for _, e := range s.Values() </span><span class="cov8" title="1">{
                result = append(result, e.(string))
        }</span>

        <span class="cov8" title="1">return</span>
}

type Version struct {
        version     string
        parts       []string
        numberParts []int
}

func newVersion(s string) *Version <span class="cov8" title="1">{
        parts := strings.Split(s, ".")
        numberParts := make([]int, len(parts))
        for i, p := range parts </span><span class="cov8" title="1">{
                numberParts[i], _ = strconv.Atoi(p)
        }</span>

        <span class="cov8" title="1">return &amp;Version{s, parts, numberParts}</span>
}

func (v *Version) Less(another *Version) int <span class="cov8" title="1">{
        minNumber := len(v.numberParts)
        if minNumber &gt; len(another.numberParts) </span><span class="cov8" title="1">{
                minNumber = len(another.numberParts)
        }</span>

        <span class="cov8" title="1">for k := 0; k &lt; minNumber; k++ </span><span class="cov8" title="1">{
                if v.numberParts[k] == another.numberParts[k] </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">return v.numberParts[k] - another.numberParts[k]</span>
        }

        <span class="cov8" title="1">for i := minNumber; i &lt; len(v.numberParts); i++ </span><span class="cov8" title="1">{
                if v.numberParts[i] &gt; 0 </span><span class="cov8" title="1">{
                        return 1
                }</span>
        }
        <span class="cov8" title="1">for i := minNumber; i &lt; len(another.numberParts); i++ </span><span class="cov8" title="1">{
                if another.numberParts[i] &gt; 0 </span><span class="cov8" title="1">{
                        return -1
                }</span>
        }

        <span class="cov8" title="1">return 0</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
